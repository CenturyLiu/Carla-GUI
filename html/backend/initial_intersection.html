<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>backend.initial_intersection API documentation</title>
<meta name="description" content="Created on Tue Jul
7 15:12:58 2020 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backend.initial_intersection</code></h1>
</header>
<section id="section-intro">
<p>Created on Tue Jul
7 15:12:58 2020</p>
<p>@author: shijiliu</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Tue Jul  7 15:12:58 2020

@author: shijiliu
&#34;&#34;&#34;
import sys
sys.path.append(&#34;..&#34;)

import carla
import matplotlib.pyplot as plt
import numpy as np
from collections import deque
import time
import math

import control # the python-control package, install first

from backend.generate_path_omit_regulation import generate_path
from backend.intersection_definition import Intersection, get_traffic_lights, get_trajectory, smooth_trajectory
from backend.carla_env import CARLA_ENV # self-written class that provides help functions, should be in the same folder
from configobj import ConfigObj
from backend.multiple_vehicle_control import VehicleControl

import copy

# color for debug use
red = carla.Color(255, 0, 0)
green = carla.Color(0, 255, 0)
blue = carla.Color(47, 210, 231)
cyan = carla.Color(0, 255, 255)
yellow = carla.Color(255, 255, 0)
orange = carla.Color(255, 162, 0)
white = carla.Color(255, 255, 255)



class Init_Intersection(Intersection):
    def __init__(self, env, world_pos, traffic_light_list, waypoint_list, subject_traffic_light_list, navigation_speed = 10.0):
        super().__init__(env, world_pos, traffic_light_list,navigation_speed = navigation_speed)
        self.waypoint_list = waypoint_list
        self.start_sim = True # the init intersection will start as soon as the simulation begins
        self.subject_traffic_light_list = subject_traffic_light_list
        self.subject_traffic_light_list.insert(0,self.subject_light)
        
        # 3 special vehicles
        self.ego_vehicle = None
        self.lead_vehicle = None
        self.follow_vehicle = None
        
        # generate the full path that&#39;s going to be shared between the ego, lead and follow vehicles
        self._generate_intersection_path()
    
    def add_ego_vehicle(self, gap = 10.0,model_name = &#34;vehicle.tesla.model3&#34;, stop_choice = &#34;abrupt&#34;, penetrate_distance = None, obey_traffic_lights = True, run = True, safety_distance = 0.0, vehicle_color = None):
        
        self._add_full_path_vehicle(&#34;ego&#34;,gap = gap, model_name = model_name, obey_traffic_lights = obey_traffic_lights, run = run, safety_distance = safety_distance, vehicle_color = vehicle_color)
        self.ego_vehicle[&#34;lead_distance&#34;] = 0.0
        self.ego_vehicle[&#34;follow_distance&#34;] = 0.0
        self.ego_vehicle[&#34;index&#34;] = len(self.subject_vehicle) - 1 # the index of the ego vehicle in the subject
        self.ego_vehicle[&#34;vehicle_type&#34;] = &#34;ego&#34;
        self.ego_vehicle[&#34;stop_choice&#34;] = stop_choice
        self.ego_vehicle[&#34;penetrate_distance&#34;] = penetrate_distance
        self.ego_vehicle[&#34;stop_ref_point&#34;] = self._generate_full_path_stop_ref(stop_choice,penetrate_distance)
        
        return self.ego_vehicle[&#39;uniquename&#39;]
        
    def add_lead_vehicle(self, lead_distance ,gap = 10.0,model_name = &#34;vehicle.tesla.model3&#34;, stop_choice = &#34;abrupt&#34;, penetrate_distance = None, obey_traffic_lights = True, run = True, safety_distance = 15.0, vehicle_color = None):
        # get all the vehicles that&#39;s going to be after the lead vehicle
        ego_index = self.ego_vehicle[&#34;index&#34;]
        vehicle_after_lead = self.subject_vehicle[ego_index : ]
        self.ego_vehicle[&#34;lead_distance&#34;] = lead_distance
        shift_distance = -(gap + 5) # should be gap + model length
        
        # shift all vehicles starting from the ego vehicle
        self._shift_vehicles(shift_distance,index = ego_index)
        
        # only keep the vehicle before the ego 
        self.subject_vehicle = self.subject_vehicle[:ego_index] 
        
        # add the lead vehicle
        self._add_full_path_vehicle(&#34;lead&#34;,gap = gap, model_name = model_name, obey_traffic_lights = obey_traffic_lights, run = run, safety_distance = safety_distance, vehicle_color = vehicle_color)
    
        # put back ego and vehicles after ego
        self.subject_vehicle += vehicle_after_lead
        
        # generate path for ego vehicle
        start_waypoint = self.ego_vehicle[&#34;ref_waypoint&#34;]
        trajectory, ref_speed_list = self._generate_full_path(start_waypoint)
        self.ego_vehicle[&#34;trajectory&#34;] = trajectory
        self.ego_vehicle[&#34;ref_speed_list&#34;] = ref_speed_list
    
        self.lead_vehicle[&#34;vehicle_type&#34;] = &#34;lead&#34;
        self.ego_vehicle[&#34;index&#34;] = ego_index + 1 # add one car in front of ego vehicle
        
        # stop settings for lead
        self.lead_vehicle[&#34;stop_choice&#34;] = stop_choice
        self.lead_vehicle[&#34;penetrate_distance&#34;] = penetrate_distance
        self.lead_vehicle[&#34;stop_ref_point&#34;] = self._generate_full_path_stop_ref(stop_choice,penetrate_distance)
        return self.lead_vehicle[&#39;uniquename&#39;]
        
    def add_follow_vehicle(self, follow_distance ,gap = 10.0,model_name = &#34;vehicle.tesla.model3&#34;, stop_choice = &#34;abrupt&#34;, penetrate_distance = None, obey_traffic_lights = True, run = True, safety_distance = 15.0, vehicle_color = None):
        # get all the vehicles that&#39;s going to be after the lead vehicle
        ego_index = self.ego_vehicle[&#34;index&#34;]
        vehicle_after_ego = self.subject_vehicle[ego_index + 1 : ]
        self.ego_vehicle[&#34;follow_distance&#34;] = follow_distance
        shift_distance = -(gap + 5) # should be gap + model length
        
        # shift all vehicles starting after the ego vehicle
        self._shift_vehicles(shift_distance,index = ego_index + 1)
        
        # only keep the vehicle until the ego 
        self.subject_vehicle = self.subject_vehicle[:ego_index + 1]
        
        # add the follow vehicle
        self._add_full_path_vehicle(&#34;follow&#34;,gap = gap, model_name = model_name, obey_traffic_lights = obey_traffic_lights, run = run, safety_distance = safety_distance, vehicle_color = vehicle_color)
        
        # put back vehicles after follow
        self.subject_vehicle += vehicle_after_ego
        
    
        self.follow_vehicle[&#34;vehicle_type&#34;] = &#34;follow&#34;
        
        # stop settings for follow vehicle
        self.follow_vehicle[&#34;stop_choice&#34;] = stop_choice
        self.follow_vehicle[&#34;penetrate_distance&#34;] = penetrate_distance
        self.follow_vehicle[&#34;stop_ref_point&#34;] = self._generate_full_path_stop_ref(stop_choice,penetrate_distance)
        return self.follow_vehicle[&#39;uniquename&#39;]
        
    def _add_full_path_vehicle(self, vehicle_type, gap = 10.0,model_name = &#34;vehicle.tesla.model3&#34;, obey_traffic_lights = True, run = True, safety_distance = 0.0, vehicle_color = None):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        vehicle_type : string
            the type of the vehicle, valid input values are &#34;ego&#34;,&#34;lead&#34;,&#34;follow&#34;
        
        gap : float, optional
            initial distance between this vehicle and the vehicle in front of it/ border. The default is 10.0.
        model_name : string, optional
            vehicle model. The default is &#34;vehicle.tesla.model3&#34;.
        obey_traffic_lights : bool, optional
            whether ego vehicle obeys traffic light. The default is True.
        run : bool, optional
            whether ego vehicle starts immediately. The default is True.
        safety_distance : float, optional
            safety distance between ego vehicle and other vehicle. The default is 0.0 since ego vehicle is allowed to crash

        Returns
        -------
        None.

        &#39;&#39;&#39;
        right_shift_value = 0.0#1.6
        
        vehicle = ConfigObj()
        
        if vehicle_type == &#34;ego&#34;:
            self.ego_vehicle = vehicle
        elif vehicle_type == &#34;lead&#34;:
            self.lead_vehicle = vehicle
        elif vehicle_type == &#34;follow&#34;:
            self.follow_vehicle = vehicle
        
        
        vehicle[&#34;model&#34;] = model_name
        vehicle[&#34;gap&#34;] = gap
        vehicle[&#34;obey_traffic_lights&#34;] = obey_traffic_lights
        vehicle[&#34;run&#34;] = run
        vehicle[&#34;safety_distance&#34;] = safety_distance
        vehicle[&#34;command&#34;] = &#34;straight&#34;
        vehicle[&#34;traffic_light&#34;] = self.subject_traffic_light_list
        ref_waypoint = self.subject_lane_ref
        vehicle_set = self.subject_vehicle
        
        if len(vehicle_set) != 0:
            ref_waypoint = vehicle_set[-1][&#34;ref_waypoint&#34;]
            #previous_uniquename = vehicle_set[-1][&#34;uniquename&#34;]
            #bb = self.env.get_vehicle_bounding_box(previous_uniquename)
            bb = vehicle_set[-1][&#34;bounding_box&#34;]
            
            right_shift_value = right_shift_value #- bb.y / 2
            
            
            
            curr_length = self.env.get_vehicle_model_length(model_name)
            
            gap += bb.x / 2 + curr_length / 2
        
        &#39;&#39;&#39;
        else:
            if gap &lt; 10.0:
                gap = 10.0 # add a constraint to the gap between the first vehicle and the lane 
                           # reference point. Add a vehicle too close to reference point
                           # will lead to vehicle not detecting the traffic light
        &#39;&#39;&#39;                
        # use the original reference point to get the new reference point
        # reference point is in the middle of the lane
        # function same as self._get_next_waypoint
        forward_vector = ref_waypoint.transform.get_forward_vector()

        location = ref_waypoint.transform.location
        raw_spawn_point = carla.Location(x = location.x - gap * forward_vector.x  , y = location.y - gap * forward_vector.y , z = location.z + 0.1)
        
        new_ref_waypoint = self.carla_map.get_waypoint(raw_spawn_point)
        
        # right shift the spawn point
        # right is with respect to the direction of vehicle navigation
        ref_yaw = new_ref_waypoint.transform.rotation.yaw
        
        right_vector = self._get_unit_right_vector(ref_yaw)
        
        new_location = new_ref_waypoint.transform.location
        
        spawn_location = carla.Location(x = new_location.x - right_shift_value * right_vector[0], y = new_location.y -  right_shift_value * right_vector[1], z = new_location.z + 0.2)
        spawn_rotation = new_ref_waypoint.transform.rotation
        
        uniquename = self.env.spawn_vehicle(model_name = model_name,spawn_point = carla.Transform(spawn_location,spawn_rotation), color = vehicle_color) 
        vehicle[&#34;uniquename&#34;] = uniquename
        vehicle[&#34;ref_waypoint&#34;] = new_ref_waypoint
        vehicle[&#34;location&#34;] = spawn_location
        vehicle[&#34;rotation&#34;] = spawn_rotation
        if vehicle_color == None:
            vehicle[&#34;vehicle_color&#34;] = vehicle_color
        else:
            vehicle[&#34;vehicle_color&#34;] = vehicle_color.replace(&#39;,&#39;,&#39;;&#39;) # replace , by ; to avoid error when importing from file
        
        # generate the full path
        trajectory, ref_speed_list = self._generate_full_path(new_ref_waypoint)
        
        vehicle[&#34;trajectory&#34;] = trajectory
        vehicle[&#34;ref_speed_list&#34;] = ref_speed_list
        
        # get the bounding box of the new vehicle
        
        new_bb = self.env.get_vehicle_bounding_box(uniquename)
        vehicle[&#34;bounding_box&#34;] = new_bb
        
        vehicle_set.append(vehicle)
    
    def _generate_full_path_stop_ref(self, stop_choice, penetrate_distance):
        &#39;&#39;&#39;
        generate the reference point for stoping the vehicle

        Returns
        -------
        stop_ref_list : list [(float,float),(float,float),...]
            a list of stop reference points

        &#39;&#39;&#39;
        
        
        stop_ref_waypoint = []
        stop_ref_waypoint.append(self.subject_lane_ref)
        
        stop_ref_list = []
        
        for ii in range(0,len(self.waypoint_list),3):
            stop_ref_waypoint.append(self.waypoint_list[ii]) # the first point of each intersection
        
        if stop_choice == &#34;normal&#34;:
            for ref_waypoint in stop_ref_waypoint:
                stop_point = self._get_next_waypoint(ref_waypoint,distance = -3.0)
                stop_ref_list.append(stop_point.transform)
        elif stop_choice == &#34;penetrate&#34;:
            for ref_waypoint in stop_ref_waypoint:
                stop_point = self._get_next_waypoint(ref_waypoint,distance = penetrate_distance)
                stop_ref_list.append(stop_point.transform)
        else:
            for ref_waypoint in stop_ref_waypoint:
                stop_ref_list.append(ref_waypoint.transform)
        
        return stop_ref_list
    
    def _generate_intersection_path(self):
        &#39;&#39;&#39;
        generate the path from the initial intersection to the end intersection

        Returns
        -------
        None.

        &#39;&#39;&#39;
        first_waypoint = self.subject_lane_ref
        second_waypoint = self.ahead_in[0] # can also be [1], choosing the left lane
        third_waypoint = self._get_next_waypoint(second_waypoint,30)
        waypoint_list = copy.copy(self.waypoint_list)
        waypoint_list.insert(0,third_waypoint)
        waypoint_list.insert(0,second_waypoint)
        waypoint_list.insert(0,first_waypoint)
        
        full_trajectory = generate_path(self.env, waypoint_list[0] , waypoint_list[1], waypoint_separation = 4)
        for ii in range(1,len(waypoint_list) - 1):
            trajectory = generate_path(self.env, waypoint_list[ii] , waypoint_list[ii + 1], waypoint_separation = 4)
            full_trajectory += trajectory[1:]
            
        self.intersection_trajectory = full_trajectory
        
        
    def _generate_full_path(self,start_waypoint):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        start_waypoint : carla.Waypoint
            initial waypoint of the vehicle.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        color = cyan
        
        trajectory = generate_path(self.env,  start_waypoint, self.subject_lane_ref, waypoint_separation = 4)
        
        full_trajectory = trajectory + self.intersection_trajectory[1:]
        
        whole_trajectory = [((pt[0],pt[1]),10.0) for pt in full_trajectory]
        
        smoothed_full_trajectory, ref_speed_list = get_trajectory(whole_trajectory) 
        
        if self.DEBUG_TRAJECTORY:
            for ii in range(1,len(smoothed_full_trajectory)):
                loc1 = carla.Location(x = smoothed_full_trajectory[ii - 1][0], y = smoothed_full_trajectory[ii - 1][1], z = 0.0)
                loc2 = carla.Location(x = smoothed_full_trajectory[ii][0], y = smoothed_full_trajectory[ii][1], z = 0.0)
                self.env.world.debug.draw_arrow(loc1, loc2, thickness = 0.05, arrow_size = 0.1, color = color, life_time=0.0, persistent_lines=True)
                
        return smoothed_full_trajectory, ref_speed_list
    
    
    def export_settings(self):
        &#39;&#39;&#39;
        export all settings for a specific intersection
        note: this method overrides the method in Intersection
              by not exporting the settings for subject lane


        Returns
        -------
        intersection_settings : ConfigObj
            settings of the intersection

        &#39;&#39;&#39;
        intersection_settings = ConfigObj()
        
        # general
        intersection_settings[&#34;navigation_speed&#34;] = self.navigation_speed
        
        # vehicles
        intersection_settings[&#34;subject_vehicle&#34;] = []
        intersection_settings[&#34;left_vehicle&#34;] = []
        intersection_settings[&#34;right_vehicle&#34;] = []
        intersection_settings[&#34;ahead_vehicle&#34;] = []
        
        # do not export subject lane settings
        &#39;&#39;&#39;
        for vehicle in self.subject_vehicle:
            # deep copy the vehicle settings
            new_vehicle = self._copy_vehicle_settings(vehicle)
            intersection_settings[&#34;subject_vehicle&#34;].append(new_vehicle)
        &#39;&#39;&#39;
        
        for vehicle in self.left_vehicle:
            # deep copy the vehicle settings
            new_vehicle = self._copy_vehicle_settings(vehicle)
            intersection_settings[&#34;left_vehicle&#34;].append(new_vehicle)
            
        for vehicle in self.right_vehicle:
            # deep copy the vehicle settings
            new_vehicle = self._copy_vehicle_settings(vehicle)
            intersection_settings[&#34;right_vehicle&#34;].append(new_vehicle)
            
        for vehicle in self.ahead_vehicle:
            # deep copy the vehicle settings
            new_vehicle = self._copy_vehicle_settings(vehicle)
            intersection_settings[&#34;ahead_vehicle&#34;].append(new_vehicle)
        
        # lights
        intersection_settings[&#34;subject_light&#34;] = copy.copy(self.light_config[&#34;subject&#34;])
        intersection_settings[&#34;subject_light_time&#34;] = copy.copy(self.light_config[&#34;subject_time&#34;])
        
        intersection_settings[&#34;left_light&#34;] = copy.copy(self.light_config[&#34;left&#34;])
        intersection_settings[&#34;left_light_time&#34;] = copy.copy(self.light_config[&#34;left_time&#34;])
        
        intersection_settings[&#34;right_light&#34;] = copy.copy(self.light_config[&#34;right&#34;])
        intersection_settings[&#34;right_light_time&#34;] = copy.copy(self.light_config[&#34;right_time&#34;])
        
        intersection_settings[&#34;ahead_light&#34;] = copy.copy(self.light_config[&#34;ahead&#34;])
        intersection_settings[&#34;ahead_light_time&#34;] = copy.copy(self.light_config[&#34;ahead_time&#34;])
        
        return intersection_settings
    
    def import_settings(self,intersection_settings):
        &#39;&#39;&#39;
        note: this method overrides the import_settings in Intersection
              by add the part of removing the ego, lead and follow vehicle
        
        Parameters
        ----------
        intersection_settings : ConfigObj
            the intersection settings we want to import

        Returns
        -------
        new_intersection_setting : ConfigObj
            settings of the intersection
            this will be generated by call self.export_settings() after finishing import
            output these settings are for the purpose of creating the front-end gui
        &#39;&#39;&#39;
        
        # remove ego, lead and follow settings 
        self.ego_vehicle = None
        self.lead_vehicle = None
        self.follow_vehicle = None
        
        # remove all vehicle in this intersection 
        # if any vehicle has been added
        for ii in range(len(self.subject_vehicle) - 1, -1, -1): # go through the array in reverse order
            uniquename = self.subject_vehicle[ii][&#39;uniquename&#39;]
            self.remove_vehicle(uniquename)
        
        for ii in range(len(self.left_vehicle) - 1, -1, -1): # go through the array in reverse order
            uniquename = self.left_vehicle[ii][&#39;uniquename&#39;]
            self.remove_vehicle(uniquename)
            
        for ii in range(len(self.right_vehicle) - 1, -1, -1): # go through the array in reverse order
            uniquename = self.right_vehicle[ii][&#39;uniquename&#39;]
            self.remove_vehicle(uniquename)
            
        for ii in range(len(self.ahead_vehicle) - 1, -1, -1): # go through the array in reverse order
            uniquename = self.ahead_vehicle[ii][&#39;uniquename&#39;]
            self.remove_vehicle(uniquename)
        
        # import all settings
       
        self.navigation_speed = float(intersection_settings[&#34;navigation_speed&#34;])
       
        &#39;&#39;&#39;
        for vehicle_config in intersection_settings[&#34;subject_vehicle&#34;]:
            # add vehicles according to imported settings
            self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                             model_name = vehicle_config[&#34;model&#34;], 
                             choice = vehicle_config[&#39;choice&#39;], 
                             command = vehicle_config[&#39;command&#39;],
                             stop_choice = vehicle_config[&#39;stop_choice&#39;],
                             penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                             obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                             run = vehicle_config[&#39;run&#39;],
                             safety_distance = vehicle_config[&#39;safety_distance&#39;],
                             vehicle_color = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;))
        &#39;&#39;&#39;
        
        for vehicle_config in intersection_settings[&#34;left_vehicle&#34;]:
            # add vehicles according to imported settings
            if vehicle_config[&#39;vehicle_color&#39;] != None:
                vehicle_config[&#39;vehicle_color&#39;] = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;)
            
            self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                             model_name = vehicle_config[&#34;model&#34;], 
                             choice = vehicle_config[&#39;choice&#39;], 
                             command = vehicle_config[&#39;command&#39;],
                             stop_choice = vehicle_config[&#39;stop_choice&#39;],
                             penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                             obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                             run = vehicle_config[&#39;run&#39;],
                             safety_distance = vehicle_config[&#39;safety_distance&#39;],
                             vehicle_color = vehicle_config[&#39;vehicle_color&#39;])
            
        for vehicle_config in intersection_settings[&#34;right_vehicle&#34;]:
            # add vehicles according to imported settings
            if vehicle_config[&#39;vehicle_color&#39;] != None:
                vehicle_config[&#39;vehicle_color&#39;] = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;)
            
            self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                             model_name = vehicle_config[&#34;model&#34;], 
                             choice = vehicle_config[&#39;choice&#39;], 
                             command = vehicle_config[&#39;command&#39;],
                             stop_choice = vehicle_config[&#39;stop_choice&#39;],
                             penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                             obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                             run = vehicle_config[&#39;run&#39;],
                             safety_distance = vehicle_config[&#39;safety_distance&#39;],
                             vehicle_color = vehicle_config[&#39;vehicle_color&#39;])
            
        for vehicle_config in intersection_settings[&#34;ahead_vehicle&#34;]:
            # add vehicles according to imported settings
            if vehicle_config[&#39;vehicle_color&#39;] != None:
                vehicle_config[&#39;vehicle_color&#39;] = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;)
            
            self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                             model_name = vehicle_config[&#34;model&#34;], 
                             choice = vehicle_config[&#39;choice&#39;], 
                             command = vehicle_config[&#39;command&#39;],
                             stop_choice = vehicle_config[&#39;stop_choice&#39;],
                             penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                             obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                             run = vehicle_config[&#39;run&#39;],
                             safety_distance = vehicle_config[&#39;safety_distance&#39;],
                             vehicle_color = vehicle_config[&#39;vehicle_color&#39;])
    
        self.light_config[&#39;subject&#39;] = intersection_settings[&#39;subject_light&#39;]
        self.light_config[&#39;subject_time&#39;] = intersection_settings[&#39;subject_light_time&#39;]
        
        self.light_config[&#39;left&#39;] = intersection_settings[&#39;left_light&#39;]
        self.light_config[&#39;left_time&#39;] = intersection_settings[&#39;left_light_time&#39;]
        
        self.light_config[&#39;right&#39;] = intersection_settings[&#39;right_light&#39;]
        self.light_config[&#39;right_time&#39;] = intersection_settings[&#39;right_light_time&#39;]
        
        self.light_config[&#39;ahead&#39;] = intersection_settings[&#39;ahead_light&#39;]
        self.light_config[&#39;ahead_time&#39;] = intersection_settings[&#39;ahead_light_time&#39;]
        
        new_intersection_setting = self.export_settings()
        return new_intersection_setting
    
    
def create_intersections(env, number_of_intersections, traffic_light_list, navigation_speed):
    &#39;&#39;&#39;
    

    Parameters
    ----------
    env : CARLA_ENV
        sself-written simulation help class.
    number_of_intersections : int
        number of intersection.
    navigation_speed : float
        the navigation speed of the vehicle

    Returns
    -------
    Intersections : list of intersections, [Init_Intersection,Intersection,Intersection,...,Intersection]

    &#39;&#39;&#39;
    
    # note: due to the limit of map, number_of_intersections can be at most 4 at present
    world_pos_list = [(-190.0,0.0),(-133.0,0.0),(-55.0,0.0),(25.4,0.0)]
    number_of_intersections = min(4,number_of_intersections)
    waypoint_list = [] # way points that form the full path
    subject_traffic_light_list = [] # all subject traffic lights along the full path 
    intersection_list = []
    
    for ii in range(1,number_of_intersections):
        normal_intersection = Intersection(env,world_pos_list[ii],traffic_light_list,navigation_speed = navigation_speed)
        waypoint_list += normal_intersection.get_subject_waypoints() # get the three points representing the path
        subject_traffic_light_list.append(normal_intersection.get_subject_traffic_light())
        intersection_list.append(normal_intersection)
        
    
    
    init_intersection = Init_Intersection(env,world_pos_list[0],traffic_light_list,waypoint_list,subject_traffic_light_list, navigation_speed = navigation_speed)
    intersection_list.insert(0,init_intersection)
    return intersection_list


def get_ego_spectator(ego_transform,distance = -10):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        ego_transform : carla.Transform
            transform for the ego vehicle.
        distance : float, optional
            &#34;distance&#34; between  ego vehicle and spectator. The default is -10.

        Returns
        -------
        next_waypoint : carla.Waypoint
            next waypoint, &#34;distance&#34; away from curr_waypoint, in the direction of the current way point
        &#39;&#39;&#39;
        forward_vector = ego_transform.get_forward_vector()

        location = ego_transform.location
        spectator_location = carla.Location(x = location.x + distance * forward_vector.x  , y = location.y + distance * forward_vector.y , z = location.z + 5.0)
        spectator_transform = carla.Transform(spectator_location,ego_transform.rotation)
        
        return spectator_transform
    

def get_ego_left_spectator(ego_transform,distance = -20):
    forward_vector = ego_transform.get_forward_vector()

    location = ego_transform.location
    spectator_location = carla.Location(x = location.x + distance * forward_vector.y  , y = location.y + distance * forward_vector.x , z = location.z + 5.0)
    spectator_rotation = carla.Rotation(roll = ego_transform.rotation.roll,pitch = ego_transform.rotation.pitch, yaw = (ego_transform.rotation.yaw + 90) % 360)
    
    spectator_transform = carla.Transform(spectator_location,spectator_rotation)
    return spectator_transform

def get_ego_driving_spectator(ego_transform, bounding_box):
    
    distance = bounding_box.x
    left_shift = -bounding_box.y * 0.3
    
    forward_vector = ego_transform.get_forward_vector()

    location = ego_transform.location
    spectator_location = carla.Location(x = location.x + distance * forward_vector.x + left_shift * forward_vector.y , y = location.y + distance * forward_vector.y + left_shift * forward_vector.x, z = location.z + bounding_box.z * 1.5)
    spectator_transform = carla.Transform(spectator_location,ego_transform.rotation)
        
    return spectator_transform

def IntersectionBackend(env,intersection_list):
    vehicle_list = []
    started_intersection_list = []
    ego_vehicle = intersection_list[0].ego_vehicle #init_intersection.ego_vehicle
    lead_vehicle = intersection_list[0].lead_vehicle
    follow_vehicle = intersection_list[0].follow_vehicle
    
    spectator = env.world.get_spectator()
    
    # assign the first full path vehicle, to determine whether 
    # each intersection should start
    if not lead_vehicle == None:
        first_full_path_vehicle_name = lead_vehicle[&#34;uniquename&#34;]
    else:
        first_full_path_vehicle_name = ego_vehicle[&#34;uniquename&#34;]
    
    # assign the vehicle for the spectator to follow
    if follow_vehicle != None:
        spectator_vehicle = follow_vehicle
    else:
        spectator_vehicle = ego_vehicle
    # get the init intersection
    init_intersection = intersection_list.pop(0)
    
    for vehicle_config in init_intersection.subject_vehicle:
        # initialize vehicles by different type (ego,lead,follow,other)
        vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
        vehicle_list.append(vehicle)
    
    for vehicle_config in init_intersection.left_vehicle:
        vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
        vehicle_list.append(vehicle)
                    
    for vehicle_config in init_intersection.right_vehicle:
        vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
        vehicle_list.append(vehicle)
        
    for vehicle_config in init_intersection.ahead_vehicle:
        vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
        vehicle_list.append(vehicle)
    

    while True:
        env.world.tick()
        
        # update the distance between vehicles after each tick
        env.update_vehicle_distance()
        
        # update the ego spectator
        if env.vehicle_available(spectator_vehicle[&#34;uniquename&#34;]):
            spectator_vehicle_transform = env.get_transform_3d(spectator_vehicle[&#34;uniquename&#34;])
            spectator_transform = get_ego_spectator(spectator_vehicle_transform,distance = -10)
            spectator.set_transform(spectator_transform)
        
        #else:
        #    spectator_transform = carla.Transform(carla.Location(x= 25.4, y=1.29, z=75.0), carla.Rotation(pitch=-88.0, yaw= -1.85, roll=1.595))
        #spectator.set_transform(spectator_transform)
        
        
        for ii in range(len(intersection_list)-1,-1,-1):
            # check whether the intersection should start
            intersection_list[ii].start_simulation(first_full_path_vehicle_name)
            if intersection_list[ii].start_sim:
                for vehicle_config in intersection_list[ii].subject_vehicle:
                    vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
                    vehicle_list.append(vehicle)
                    
                for vehicle_config in intersection_list[ii].left_vehicle:
                    vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
                    vehicle_list.append(vehicle)
                    
                for vehicle_config in intersection_list[ii].right_vehicle:
                    vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
                    vehicle_list.append(vehicle)
        
                for vehicle_config in intersection_list[ii].ahead_vehicle:
                    vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
                    vehicle_list.append(vehicle)
                
                # move the intersection to started intersection list
                intersection = intersection_list.pop(ii)
                started_intersection_list.append(intersection)
                
        if len(vehicle_list) == 0:
            break        
                
        for jj in range(len(vehicle_list) -1, -1, -1):
            vehicle = vehicle_list[jj]
            if vehicle.run:
                end_trajectory = vehicle.pure_pursuit_control_wrapper()
                if end_trajectory:
                    vehicle_list.pop(jj)

def main():
    try:
        client = carla.Client(&#34;localhost&#34;,2000)
        client.set_timeout(10.0)
        world = client.load_world(&#39;Town05&#39;)
         
        # set the weather
        weather = carla.WeatherParameters(
            cloudiness=10.0,
            precipitation=0.0,
            sun_altitude_angle=90.0)
        world.set_weather(weather)
        
        # set the spectator position for demo purpose
        spectator = world.get_spectator()
        spectator.set_transform(carla.Transform(carla.Location(x=-190, y=1.29, z=75.0), carla.Rotation(pitch=-88.0, yaw= -1.85, roll=1.595))) # top view of intersection
        
        env = CARLA_ENV(world) 
        time.sleep(2) # sleep for 2 seconds, wait the initialization to finish
        
        traffic_light_list = get_traffic_lights(world.get_actors())
        
        intersection_list = create_intersections(env, 4, traffic_light_list)
        init_intersection = intersection_list[0]
        normal_intersections = intersection_list[1:]
        init_intersection.add_ego_vehicle(safety_distance = 15.0 )
        init_intersection.add_follow_vehicle(follow_distance = 20.0)
        init_intersection.add_lead_vehicle(lead_distance = 20.0)
        init_intersection.add_vehicle(choice = &#34;left&#34;)
        init_intersection.add_vehicle(choice = &#34;right&#34;,command=&#34;left&#34;)
        init_intersection.add_vehicle(choice = &#34;ahead&#34;,command=&#34;left&#34;)
        init_intersection.add_vehicle(choice = &#34;ahead&#34;,command = &#34;right&#34;)
        
        intersection_list[1].add_vehicle(choice = &#34;ahead&#34;)
        intersection_list[1].add_vehicle(choice = &#34;left&#34;,command=&#34;left&#34;)
        intersection_list[1].add_vehicle(choice = &#34;right&#34;,command = &#34;left&#34;)
        intersection_list[1].add_vehicle(choice = &#34;right&#34;,command = &#34;right&#34;)
        intersection_list[1]._shift_vehicles(-10, choice = &#34;right&#34;,index = 0)
        
        intersection_list[2].add_vehicle(choice = &#34;ahead&#34;)
        intersection_list[2].add_vehicle(choice = &#34;left&#34;,command=&#34;left&#34;)
        intersection_list[2].add_vehicle(choice = &#34;right&#34;,command = &#34;left&#34;)
        intersection_list[2].add_vehicle(choice = &#34;right&#34;,command = &#34;right&#34;)
        
        intersection_list[3].add_vehicle(command = &#34;left&#34;)
        intersection_list[3].add_vehicle()
        
        
        IntersectionBackend(env,intersection_list)
    finally:
        time.sleep(10)
        env.destroy_actors()
        
if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="backend.initial_intersection.IntersectionBackend"><code class="name flex">
<span>def <span class="ident">IntersectionBackend</span></span>(<span>env, intersection_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IntersectionBackend(env,intersection_list):
    vehicle_list = []
    started_intersection_list = []
    ego_vehicle = intersection_list[0].ego_vehicle #init_intersection.ego_vehicle
    lead_vehicle = intersection_list[0].lead_vehicle
    follow_vehicle = intersection_list[0].follow_vehicle
    
    spectator = env.world.get_spectator()
    
    # assign the first full path vehicle, to determine whether 
    # each intersection should start
    if not lead_vehicle == None:
        first_full_path_vehicle_name = lead_vehicle[&#34;uniquename&#34;]
    else:
        first_full_path_vehicle_name = ego_vehicle[&#34;uniquename&#34;]
    
    # assign the vehicle for the spectator to follow
    if follow_vehicle != None:
        spectator_vehicle = follow_vehicle
    else:
        spectator_vehicle = ego_vehicle
    # get the init intersection
    init_intersection = intersection_list.pop(0)
    
    for vehicle_config in init_intersection.subject_vehicle:
        # initialize vehicles by different type (ego,lead,follow,other)
        vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
        vehicle_list.append(vehicle)
    
    for vehicle_config in init_intersection.left_vehicle:
        vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
        vehicle_list.append(vehicle)
                    
    for vehicle_config in init_intersection.right_vehicle:
        vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
        vehicle_list.append(vehicle)
        
    for vehicle_config in init_intersection.ahead_vehicle:
        vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
        vehicle_list.append(vehicle)
    

    while True:
        env.world.tick()
        
        # update the distance between vehicles after each tick
        env.update_vehicle_distance()
        
        # update the ego spectator
        if env.vehicle_available(spectator_vehicle[&#34;uniquename&#34;]):
            spectator_vehicle_transform = env.get_transform_3d(spectator_vehicle[&#34;uniquename&#34;])
            spectator_transform = get_ego_spectator(spectator_vehicle_transform,distance = -10)
            spectator.set_transform(spectator_transform)
        
        #else:
        #    spectator_transform = carla.Transform(carla.Location(x= 25.4, y=1.29, z=75.0), carla.Rotation(pitch=-88.0, yaw= -1.85, roll=1.595))
        #spectator.set_transform(spectator_transform)
        
        
        for ii in range(len(intersection_list)-1,-1,-1):
            # check whether the intersection should start
            intersection_list[ii].start_simulation(first_full_path_vehicle_name)
            if intersection_list[ii].start_sim:
                for vehicle_config in intersection_list[ii].subject_vehicle:
                    vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
                    vehicle_list.append(vehicle)
                    
                for vehicle_config in intersection_list[ii].left_vehicle:
                    vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
                    vehicle_list.append(vehicle)
                    
                for vehicle_config in intersection_list[ii].right_vehicle:
                    vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
                    vehicle_list.append(vehicle)
        
                for vehicle_config in intersection_list[ii].ahead_vehicle:
                    vehicle = VehicleControl(env, vehicle_config, env.delta_seconds)
                    vehicle_list.append(vehicle)
                
                # move the intersection to started intersection list
                intersection = intersection_list.pop(ii)
                started_intersection_list.append(intersection)
                
        if len(vehicle_list) == 0:
            break        
                
        for jj in range(len(vehicle_list) -1, -1, -1):
            vehicle = vehicle_list[jj]
            if vehicle.run:
                end_trajectory = vehicle.pure_pursuit_control_wrapper()
                if end_trajectory:
                    vehicle_list.pop(jj)</code></pre>
</details>
</dd>
<dt id="backend.initial_intersection.create_intersections"><code class="name flex">
<span>def <span class="ident">create_intersections</span></span>(<span>env, number_of_intersections, traffic_light_list, navigation_speed)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>env</code></strong> :&ensp;<code>CARLA_ENV</code></dt>
<dd>sself-written simulation help class.</dd>
<dt><strong><code>number_of_intersections</code></strong> :&ensp;<code>int</code></dt>
<dd>number of intersection.</dd>
<dt><strong><code>navigation_speed</code></strong> :&ensp;<code>float</code></dt>
<dd>the navigation speed of the vehicle</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Intersections</code></strong> :&ensp;<code>list</code> of <code>intersections, [<a title="backend.initial_intersection.Init_Intersection" href="#backend.initial_intersection.Init_Intersection">Init_Intersection</a>,Intersection,Intersection,&hellip;,Intersection]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_intersections(env, number_of_intersections, traffic_light_list, navigation_speed):
    &#39;&#39;&#39;
    

    Parameters
    ----------
    env : CARLA_ENV
        sself-written simulation help class.
    number_of_intersections : int
        number of intersection.
    navigation_speed : float
        the navigation speed of the vehicle

    Returns
    -------
    Intersections : list of intersections, [Init_Intersection,Intersection,Intersection,...,Intersection]

    &#39;&#39;&#39;
    
    # note: due to the limit of map, number_of_intersections can be at most 4 at present
    world_pos_list = [(-190.0,0.0),(-133.0,0.0),(-55.0,0.0),(25.4,0.0)]
    number_of_intersections = min(4,number_of_intersections)
    waypoint_list = [] # way points that form the full path
    subject_traffic_light_list = [] # all subject traffic lights along the full path 
    intersection_list = []
    
    for ii in range(1,number_of_intersections):
        normal_intersection = Intersection(env,world_pos_list[ii],traffic_light_list,navigation_speed = navigation_speed)
        waypoint_list += normal_intersection.get_subject_waypoints() # get the three points representing the path
        subject_traffic_light_list.append(normal_intersection.get_subject_traffic_light())
        intersection_list.append(normal_intersection)
        
    
    
    init_intersection = Init_Intersection(env,world_pos_list[0],traffic_light_list,waypoint_list,subject_traffic_light_list, navigation_speed = navigation_speed)
    intersection_list.insert(0,init_intersection)
    return intersection_list</code></pre>
</details>
</dd>
<dt id="backend.initial_intersection.get_ego_driving_spectator"><code class="name flex">
<span>def <span class="ident">get_ego_driving_spectator</span></span>(<span>ego_transform, bounding_box)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ego_driving_spectator(ego_transform, bounding_box):
    
    distance = bounding_box.x
    left_shift = -bounding_box.y * 0.3
    
    forward_vector = ego_transform.get_forward_vector()

    location = ego_transform.location
    spectator_location = carla.Location(x = location.x + distance * forward_vector.x + left_shift * forward_vector.y , y = location.y + distance * forward_vector.y + left_shift * forward_vector.x, z = location.z + bounding_box.z * 1.5)
    spectator_transform = carla.Transform(spectator_location,ego_transform.rotation)
        
    return spectator_transform</code></pre>
</details>
</dd>
<dt id="backend.initial_intersection.get_ego_left_spectator"><code class="name flex">
<span>def <span class="ident">get_ego_left_spectator</span></span>(<span>ego_transform, distance=-20)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ego_left_spectator(ego_transform,distance = -20):
    forward_vector = ego_transform.get_forward_vector()

    location = ego_transform.location
    spectator_location = carla.Location(x = location.x + distance * forward_vector.y  , y = location.y + distance * forward_vector.x , z = location.z + 5.0)
    spectator_rotation = carla.Rotation(roll = ego_transform.rotation.roll,pitch = ego_transform.rotation.pitch, yaw = (ego_transform.rotation.yaw + 90) % 360)
    
    spectator_transform = carla.Transform(spectator_location,spectator_rotation)
    return spectator_transform</code></pre>
</details>
</dd>
<dt id="backend.initial_intersection.get_ego_spectator"><code class="name flex">
<span>def <span class="ident">get_ego_spectator</span></span>(<span>ego_transform, distance=-10)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ego_transform</code></strong> :&ensp;<code>carla.Transform</code></dt>
<dd>transform for the ego vehicle.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>"distance" between
ego vehicle and spectator. The default is -10.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>next_waypoint</code></strong> :&ensp;<code>carla.Waypoint</code></dt>
<dd>next waypoint, "distance" away from curr_waypoint, in the direction of the current way point</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ego_spectator(ego_transform,distance = -10):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        ego_transform : carla.Transform
            transform for the ego vehicle.
        distance : float, optional
            &#34;distance&#34; between  ego vehicle and spectator. The default is -10.

        Returns
        -------
        next_waypoint : carla.Waypoint
            next waypoint, &#34;distance&#34; away from curr_waypoint, in the direction of the current way point
        &#39;&#39;&#39;
        forward_vector = ego_transform.get_forward_vector()

        location = ego_transform.location
        spectator_location = carla.Location(x = location.x + distance * forward_vector.x  , y = location.y + distance * forward_vector.y , z = location.z + 5.0)
        spectator_transform = carla.Transform(spectator_location,ego_transform.rotation)
        
        return spectator_transform</code></pre>
</details>
</dd>
<dt id="backend.initial_intersection.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    try:
        client = carla.Client(&#34;localhost&#34;,2000)
        client.set_timeout(10.0)
        world = client.load_world(&#39;Town05&#39;)
         
        # set the weather
        weather = carla.WeatherParameters(
            cloudiness=10.0,
            precipitation=0.0,
            sun_altitude_angle=90.0)
        world.set_weather(weather)
        
        # set the spectator position for demo purpose
        spectator = world.get_spectator()
        spectator.set_transform(carla.Transform(carla.Location(x=-190, y=1.29, z=75.0), carla.Rotation(pitch=-88.0, yaw= -1.85, roll=1.595))) # top view of intersection
        
        env = CARLA_ENV(world) 
        time.sleep(2) # sleep for 2 seconds, wait the initialization to finish
        
        traffic_light_list = get_traffic_lights(world.get_actors())
        
        intersection_list = create_intersections(env, 4, traffic_light_list)
        init_intersection = intersection_list[0]
        normal_intersections = intersection_list[1:]
        init_intersection.add_ego_vehicle(safety_distance = 15.0 )
        init_intersection.add_follow_vehicle(follow_distance = 20.0)
        init_intersection.add_lead_vehicle(lead_distance = 20.0)
        init_intersection.add_vehicle(choice = &#34;left&#34;)
        init_intersection.add_vehicle(choice = &#34;right&#34;,command=&#34;left&#34;)
        init_intersection.add_vehicle(choice = &#34;ahead&#34;,command=&#34;left&#34;)
        init_intersection.add_vehicle(choice = &#34;ahead&#34;,command = &#34;right&#34;)
        
        intersection_list[1].add_vehicle(choice = &#34;ahead&#34;)
        intersection_list[1].add_vehicle(choice = &#34;left&#34;,command=&#34;left&#34;)
        intersection_list[1].add_vehicle(choice = &#34;right&#34;,command = &#34;left&#34;)
        intersection_list[1].add_vehicle(choice = &#34;right&#34;,command = &#34;right&#34;)
        intersection_list[1]._shift_vehicles(-10, choice = &#34;right&#34;,index = 0)
        
        intersection_list[2].add_vehicle(choice = &#34;ahead&#34;)
        intersection_list[2].add_vehicle(choice = &#34;left&#34;,command=&#34;left&#34;)
        intersection_list[2].add_vehicle(choice = &#34;right&#34;,command = &#34;left&#34;)
        intersection_list[2].add_vehicle(choice = &#34;right&#34;,command = &#34;right&#34;)
        
        intersection_list[3].add_vehicle(command = &#34;left&#34;)
        intersection_list[3].add_vehicle()
        
        
        IntersectionBackend(env,intersection_list)
    finally:
        time.sleep(10)
        env.destroy_actors()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backend.initial_intersection.Init_Intersection"><code class="flex name class">
<span>class <span class="ident">Init_Intersection</span></span>
<span>(</span><span>env, world_pos, traffic_light_list, waypoint_list, subject_traffic_light_list, navigation_speed=10.0)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>env</code></strong> :&ensp;<code>CARLA_ENV</code></dt>
<dd>the simulation environment</dd>
<dt><strong><code>world_pos</code></strong> :&ensp;<code>(float,float)</code></dt>
<dd>the (rough) central point of the intersection.</dd>
<dt><strong><code>traffic_light_list</code></strong> :&ensp;<code>list</code></dt>
<dd>list of all available traffic lights.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>width and height of the intersection. The default is 75.0 (m).</dd>
<dt><strong><code>yaw</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>define the direction the ego vehicle will pass through the intersection. The default is 0.</dd>
<dt><strong><code>navigation_speed</code></strong> :&ensp;<code>float</code></dt>
<dd>the navigation speed of the vehicle</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Init_Intersection(Intersection):
    def __init__(self, env, world_pos, traffic_light_list, waypoint_list, subject_traffic_light_list, navigation_speed = 10.0):
        super().__init__(env, world_pos, traffic_light_list,navigation_speed = navigation_speed)
        self.waypoint_list = waypoint_list
        self.start_sim = True # the init intersection will start as soon as the simulation begins
        self.subject_traffic_light_list = subject_traffic_light_list
        self.subject_traffic_light_list.insert(0,self.subject_light)
        
        # 3 special vehicles
        self.ego_vehicle = None
        self.lead_vehicle = None
        self.follow_vehicle = None
        
        # generate the full path that&#39;s going to be shared between the ego, lead and follow vehicles
        self._generate_intersection_path()
    
    def add_ego_vehicle(self, gap = 10.0,model_name = &#34;vehicle.tesla.model3&#34;, stop_choice = &#34;abrupt&#34;, penetrate_distance = None, obey_traffic_lights = True, run = True, safety_distance = 0.0, vehicle_color = None):
        
        self._add_full_path_vehicle(&#34;ego&#34;,gap = gap, model_name = model_name, obey_traffic_lights = obey_traffic_lights, run = run, safety_distance = safety_distance, vehicle_color = vehicle_color)
        self.ego_vehicle[&#34;lead_distance&#34;] = 0.0
        self.ego_vehicle[&#34;follow_distance&#34;] = 0.0
        self.ego_vehicle[&#34;index&#34;] = len(self.subject_vehicle) - 1 # the index of the ego vehicle in the subject
        self.ego_vehicle[&#34;vehicle_type&#34;] = &#34;ego&#34;
        self.ego_vehicle[&#34;stop_choice&#34;] = stop_choice
        self.ego_vehicle[&#34;penetrate_distance&#34;] = penetrate_distance
        self.ego_vehicle[&#34;stop_ref_point&#34;] = self._generate_full_path_stop_ref(stop_choice,penetrate_distance)
        
        return self.ego_vehicle[&#39;uniquename&#39;]
        
    def add_lead_vehicle(self, lead_distance ,gap = 10.0,model_name = &#34;vehicle.tesla.model3&#34;, stop_choice = &#34;abrupt&#34;, penetrate_distance = None, obey_traffic_lights = True, run = True, safety_distance = 15.0, vehicle_color = None):
        # get all the vehicles that&#39;s going to be after the lead vehicle
        ego_index = self.ego_vehicle[&#34;index&#34;]
        vehicle_after_lead = self.subject_vehicle[ego_index : ]
        self.ego_vehicle[&#34;lead_distance&#34;] = lead_distance
        shift_distance = -(gap + 5) # should be gap + model length
        
        # shift all vehicles starting from the ego vehicle
        self._shift_vehicles(shift_distance,index = ego_index)
        
        # only keep the vehicle before the ego 
        self.subject_vehicle = self.subject_vehicle[:ego_index] 
        
        # add the lead vehicle
        self._add_full_path_vehicle(&#34;lead&#34;,gap = gap, model_name = model_name, obey_traffic_lights = obey_traffic_lights, run = run, safety_distance = safety_distance, vehicle_color = vehicle_color)
    
        # put back ego and vehicles after ego
        self.subject_vehicle += vehicle_after_lead
        
        # generate path for ego vehicle
        start_waypoint = self.ego_vehicle[&#34;ref_waypoint&#34;]
        trajectory, ref_speed_list = self._generate_full_path(start_waypoint)
        self.ego_vehicle[&#34;trajectory&#34;] = trajectory
        self.ego_vehicle[&#34;ref_speed_list&#34;] = ref_speed_list
    
        self.lead_vehicle[&#34;vehicle_type&#34;] = &#34;lead&#34;
        self.ego_vehicle[&#34;index&#34;] = ego_index + 1 # add one car in front of ego vehicle
        
        # stop settings for lead
        self.lead_vehicle[&#34;stop_choice&#34;] = stop_choice
        self.lead_vehicle[&#34;penetrate_distance&#34;] = penetrate_distance
        self.lead_vehicle[&#34;stop_ref_point&#34;] = self._generate_full_path_stop_ref(stop_choice,penetrate_distance)
        return self.lead_vehicle[&#39;uniquename&#39;]
        
    def add_follow_vehicle(self, follow_distance ,gap = 10.0,model_name = &#34;vehicle.tesla.model3&#34;, stop_choice = &#34;abrupt&#34;, penetrate_distance = None, obey_traffic_lights = True, run = True, safety_distance = 15.0, vehicle_color = None):
        # get all the vehicles that&#39;s going to be after the lead vehicle
        ego_index = self.ego_vehicle[&#34;index&#34;]
        vehicle_after_ego = self.subject_vehicle[ego_index + 1 : ]
        self.ego_vehicle[&#34;follow_distance&#34;] = follow_distance
        shift_distance = -(gap + 5) # should be gap + model length
        
        # shift all vehicles starting after the ego vehicle
        self._shift_vehicles(shift_distance,index = ego_index + 1)
        
        # only keep the vehicle until the ego 
        self.subject_vehicle = self.subject_vehicle[:ego_index + 1]
        
        # add the follow vehicle
        self._add_full_path_vehicle(&#34;follow&#34;,gap = gap, model_name = model_name, obey_traffic_lights = obey_traffic_lights, run = run, safety_distance = safety_distance, vehicle_color = vehicle_color)
        
        # put back vehicles after follow
        self.subject_vehicle += vehicle_after_ego
        
    
        self.follow_vehicle[&#34;vehicle_type&#34;] = &#34;follow&#34;
        
        # stop settings for follow vehicle
        self.follow_vehicle[&#34;stop_choice&#34;] = stop_choice
        self.follow_vehicle[&#34;penetrate_distance&#34;] = penetrate_distance
        self.follow_vehicle[&#34;stop_ref_point&#34;] = self._generate_full_path_stop_ref(stop_choice,penetrate_distance)
        return self.follow_vehicle[&#39;uniquename&#39;]
        
    def _add_full_path_vehicle(self, vehicle_type, gap = 10.0,model_name = &#34;vehicle.tesla.model3&#34;, obey_traffic_lights = True, run = True, safety_distance = 0.0, vehicle_color = None):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        vehicle_type : string
            the type of the vehicle, valid input values are &#34;ego&#34;,&#34;lead&#34;,&#34;follow&#34;
        
        gap : float, optional
            initial distance between this vehicle and the vehicle in front of it/ border. The default is 10.0.
        model_name : string, optional
            vehicle model. The default is &#34;vehicle.tesla.model3&#34;.
        obey_traffic_lights : bool, optional
            whether ego vehicle obeys traffic light. The default is True.
        run : bool, optional
            whether ego vehicle starts immediately. The default is True.
        safety_distance : float, optional
            safety distance between ego vehicle and other vehicle. The default is 0.0 since ego vehicle is allowed to crash

        Returns
        -------
        None.

        &#39;&#39;&#39;
        right_shift_value = 0.0#1.6
        
        vehicle = ConfigObj()
        
        if vehicle_type == &#34;ego&#34;:
            self.ego_vehicle = vehicle
        elif vehicle_type == &#34;lead&#34;:
            self.lead_vehicle = vehicle
        elif vehicle_type == &#34;follow&#34;:
            self.follow_vehicle = vehicle
        
        
        vehicle[&#34;model&#34;] = model_name
        vehicle[&#34;gap&#34;] = gap
        vehicle[&#34;obey_traffic_lights&#34;] = obey_traffic_lights
        vehicle[&#34;run&#34;] = run
        vehicle[&#34;safety_distance&#34;] = safety_distance
        vehicle[&#34;command&#34;] = &#34;straight&#34;
        vehicle[&#34;traffic_light&#34;] = self.subject_traffic_light_list
        ref_waypoint = self.subject_lane_ref
        vehicle_set = self.subject_vehicle
        
        if len(vehicle_set) != 0:
            ref_waypoint = vehicle_set[-1][&#34;ref_waypoint&#34;]
            #previous_uniquename = vehicle_set[-1][&#34;uniquename&#34;]
            #bb = self.env.get_vehicle_bounding_box(previous_uniquename)
            bb = vehicle_set[-1][&#34;bounding_box&#34;]
            
            right_shift_value = right_shift_value #- bb.y / 2
            
            
            
            curr_length = self.env.get_vehicle_model_length(model_name)
            
            gap += bb.x / 2 + curr_length / 2
        
        &#39;&#39;&#39;
        else:
            if gap &lt; 10.0:
                gap = 10.0 # add a constraint to the gap between the first vehicle and the lane 
                           # reference point. Add a vehicle too close to reference point
                           # will lead to vehicle not detecting the traffic light
        &#39;&#39;&#39;                
        # use the original reference point to get the new reference point
        # reference point is in the middle of the lane
        # function same as self._get_next_waypoint
        forward_vector = ref_waypoint.transform.get_forward_vector()

        location = ref_waypoint.transform.location
        raw_spawn_point = carla.Location(x = location.x - gap * forward_vector.x  , y = location.y - gap * forward_vector.y , z = location.z + 0.1)
        
        new_ref_waypoint = self.carla_map.get_waypoint(raw_spawn_point)
        
        # right shift the spawn point
        # right is with respect to the direction of vehicle navigation
        ref_yaw = new_ref_waypoint.transform.rotation.yaw
        
        right_vector = self._get_unit_right_vector(ref_yaw)
        
        new_location = new_ref_waypoint.transform.location
        
        spawn_location = carla.Location(x = new_location.x - right_shift_value * right_vector[0], y = new_location.y -  right_shift_value * right_vector[1], z = new_location.z + 0.2)
        spawn_rotation = new_ref_waypoint.transform.rotation
        
        uniquename = self.env.spawn_vehicle(model_name = model_name,spawn_point = carla.Transform(spawn_location,spawn_rotation), color = vehicle_color) 
        vehicle[&#34;uniquename&#34;] = uniquename
        vehicle[&#34;ref_waypoint&#34;] = new_ref_waypoint
        vehicle[&#34;location&#34;] = spawn_location
        vehicle[&#34;rotation&#34;] = spawn_rotation
        if vehicle_color == None:
            vehicle[&#34;vehicle_color&#34;] = vehicle_color
        else:
            vehicle[&#34;vehicle_color&#34;] = vehicle_color.replace(&#39;,&#39;,&#39;;&#39;) # replace , by ; to avoid error when importing from file
        
        # generate the full path
        trajectory, ref_speed_list = self._generate_full_path(new_ref_waypoint)
        
        vehicle[&#34;trajectory&#34;] = trajectory
        vehicle[&#34;ref_speed_list&#34;] = ref_speed_list
        
        # get the bounding box of the new vehicle
        
        new_bb = self.env.get_vehicle_bounding_box(uniquename)
        vehicle[&#34;bounding_box&#34;] = new_bb
        
        vehicle_set.append(vehicle)
    
    def _generate_full_path_stop_ref(self, stop_choice, penetrate_distance):
        &#39;&#39;&#39;
        generate the reference point for stoping the vehicle

        Returns
        -------
        stop_ref_list : list [(float,float),(float,float),...]
            a list of stop reference points

        &#39;&#39;&#39;
        
        
        stop_ref_waypoint = []
        stop_ref_waypoint.append(self.subject_lane_ref)
        
        stop_ref_list = []
        
        for ii in range(0,len(self.waypoint_list),3):
            stop_ref_waypoint.append(self.waypoint_list[ii]) # the first point of each intersection
        
        if stop_choice == &#34;normal&#34;:
            for ref_waypoint in stop_ref_waypoint:
                stop_point = self._get_next_waypoint(ref_waypoint,distance = -3.0)
                stop_ref_list.append(stop_point.transform)
        elif stop_choice == &#34;penetrate&#34;:
            for ref_waypoint in stop_ref_waypoint:
                stop_point = self._get_next_waypoint(ref_waypoint,distance = penetrate_distance)
                stop_ref_list.append(stop_point.transform)
        else:
            for ref_waypoint in stop_ref_waypoint:
                stop_ref_list.append(ref_waypoint.transform)
        
        return stop_ref_list
    
    def _generate_intersection_path(self):
        &#39;&#39;&#39;
        generate the path from the initial intersection to the end intersection

        Returns
        -------
        None.

        &#39;&#39;&#39;
        first_waypoint = self.subject_lane_ref
        second_waypoint = self.ahead_in[0] # can also be [1], choosing the left lane
        third_waypoint = self._get_next_waypoint(second_waypoint,30)
        waypoint_list = copy.copy(self.waypoint_list)
        waypoint_list.insert(0,third_waypoint)
        waypoint_list.insert(0,second_waypoint)
        waypoint_list.insert(0,first_waypoint)
        
        full_trajectory = generate_path(self.env, waypoint_list[0] , waypoint_list[1], waypoint_separation = 4)
        for ii in range(1,len(waypoint_list) - 1):
            trajectory = generate_path(self.env, waypoint_list[ii] , waypoint_list[ii + 1], waypoint_separation = 4)
            full_trajectory += trajectory[1:]
            
        self.intersection_trajectory = full_trajectory
        
        
    def _generate_full_path(self,start_waypoint):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        start_waypoint : carla.Waypoint
            initial waypoint of the vehicle.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        color = cyan
        
        trajectory = generate_path(self.env,  start_waypoint, self.subject_lane_ref, waypoint_separation = 4)
        
        full_trajectory = trajectory + self.intersection_trajectory[1:]
        
        whole_trajectory = [((pt[0],pt[1]),10.0) for pt in full_trajectory]
        
        smoothed_full_trajectory, ref_speed_list = get_trajectory(whole_trajectory) 
        
        if self.DEBUG_TRAJECTORY:
            for ii in range(1,len(smoothed_full_trajectory)):
                loc1 = carla.Location(x = smoothed_full_trajectory[ii - 1][0], y = smoothed_full_trajectory[ii - 1][1], z = 0.0)
                loc2 = carla.Location(x = smoothed_full_trajectory[ii][0], y = smoothed_full_trajectory[ii][1], z = 0.0)
                self.env.world.debug.draw_arrow(loc1, loc2, thickness = 0.05, arrow_size = 0.1, color = color, life_time=0.0, persistent_lines=True)
                
        return smoothed_full_trajectory, ref_speed_list
    
    
    def export_settings(self):
        &#39;&#39;&#39;
        export all settings for a specific intersection
        note: this method overrides the method in Intersection
              by not exporting the settings for subject lane


        Returns
        -------
        intersection_settings : ConfigObj
            settings of the intersection

        &#39;&#39;&#39;
        intersection_settings = ConfigObj()
        
        # general
        intersection_settings[&#34;navigation_speed&#34;] = self.navigation_speed
        
        # vehicles
        intersection_settings[&#34;subject_vehicle&#34;] = []
        intersection_settings[&#34;left_vehicle&#34;] = []
        intersection_settings[&#34;right_vehicle&#34;] = []
        intersection_settings[&#34;ahead_vehicle&#34;] = []
        
        # do not export subject lane settings
        &#39;&#39;&#39;
        for vehicle in self.subject_vehicle:
            # deep copy the vehicle settings
            new_vehicle = self._copy_vehicle_settings(vehicle)
            intersection_settings[&#34;subject_vehicle&#34;].append(new_vehicle)
        &#39;&#39;&#39;
        
        for vehicle in self.left_vehicle:
            # deep copy the vehicle settings
            new_vehicle = self._copy_vehicle_settings(vehicle)
            intersection_settings[&#34;left_vehicle&#34;].append(new_vehicle)
            
        for vehicle in self.right_vehicle:
            # deep copy the vehicle settings
            new_vehicle = self._copy_vehicle_settings(vehicle)
            intersection_settings[&#34;right_vehicle&#34;].append(new_vehicle)
            
        for vehicle in self.ahead_vehicle:
            # deep copy the vehicle settings
            new_vehicle = self._copy_vehicle_settings(vehicle)
            intersection_settings[&#34;ahead_vehicle&#34;].append(new_vehicle)
        
        # lights
        intersection_settings[&#34;subject_light&#34;] = copy.copy(self.light_config[&#34;subject&#34;])
        intersection_settings[&#34;subject_light_time&#34;] = copy.copy(self.light_config[&#34;subject_time&#34;])
        
        intersection_settings[&#34;left_light&#34;] = copy.copy(self.light_config[&#34;left&#34;])
        intersection_settings[&#34;left_light_time&#34;] = copy.copy(self.light_config[&#34;left_time&#34;])
        
        intersection_settings[&#34;right_light&#34;] = copy.copy(self.light_config[&#34;right&#34;])
        intersection_settings[&#34;right_light_time&#34;] = copy.copy(self.light_config[&#34;right_time&#34;])
        
        intersection_settings[&#34;ahead_light&#34;] = copy.copy(self.light_config[&#34;ahead&#34;])
        intersection_settings[&#34;ahead_light_time&#34;] = copy.copy(self.light_config[&#34;ahead_time&#34;])
        
        return intersection_settings
    
    def import_settings(self,intersection_settings):
        &#39;&#39;&#39;
        note: this method overrides the import_settings in Intersection
              by add the part of removing the ego, lead and follow vehicle
        
        Parameters
        ----------
        intersection_settings : ConfigObj
            the intersection settings we want to import

        Returns
        -------
        new_intersection_setting : ConfigObj
            settings of the intersection
            this will be generated by call self.export_settings() after finishing import
            output these settings are for the purpose of creating the front-end gui
        &#39;&#39;&#39;
        
        # remove ego, lead and follow settings 
        self.ego_vehicle = None
        self.lead_vehicle = None
        self.follow_vehicle = None
        
        # remove all vehicle in this intersection 
        # if any vehicle has been added
        for ii in range(len(self.subject_vehicle) - 1, -1, -1): # go through the array in reverse order
            uniquename = self.subject_vehicle[ii][&#39;uniquename&#39;]
            self.remove_vehicle(uniquename)
        
        for ii in range(len(self.left_vehicle) - 1, -1, -1): # go through the array in reverse order
            uniquename = self.left_vehicle[ii][&#39;uniquename&#39;]
            self.remove_vehicle(uniquename)
            
        for ii in range(len(self.right_vehicle) - 1, -1, -1): # go through the array in reverse order
            uniquename = self.right_vehicle[ii][&#39;uniquename&#39;]
            self.remove_vehicle(uniquename)
            
        for ii in range(len(self.ahead_vehicle) - 1, -1, -1): # go through the array in reverse order
            uniquename = self.ahead_vehicle[ii][&#39;uniquename&#39;]
            self.remove_vehicle(uniquename)
        
        # import all settings
       
        self.navigation_speed = float(intersection_settings[&#34;navigation_speed&#34;])
       
        &#39;&#39;&#39;
        for vehicle_config in intersection_settings[&#34;subject_vehicle&#34;]:
            # add vehicles according to imported settings
            self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                             model_name = vehicle_config[&#34;model&#34;], 
                             choice = vehicle_config[&#39;choice&#39;], 
                             command = vehicle_config[&#39;command&#39;],
                             stop_choice = vehicle_config[&#39;stop_choice&#39;],
                             penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                             obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                             run = vehicle_config[&#39;run&#39;],
                             safety_distance = vehicle_config[&#39;safety_distance&#39;],
                             vehicle_color = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;))
        &#39;&#39;&#39;
        
        for vehicle_config in intersection_settings[&#34;left_vehicle&#34;]:
            # add vehicles according to imported settings
            if vehicle_config[&#39;vehicle_color&#39;] != None:
                vehicle_config[&#39;vehicle_color&#39;] = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;)
            
            self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                             model_name = vehicle_config[&#34;model&#34;], 
                             choice = vehicle_config[&#39;choice&#39;], 
                             command = vehicle_config[&#39;command&#39;],
                             stop_choice = vehicle_config[&#39;stop_choice&#39;],
                             penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                             obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                             run = vehicle_config[&#39;run&#39;],
                             safety_distance = vehicle_config[&#39;safety_distance&#39;],
                             vehicle_color = vehicle_config[&#39;vehicle_color&#39;])
            
        for vehicle_config in intersection_settings[&#34;right_vehicle&#34;]:
            # add vehicles according to imported settings
            if vehicle_config[&#39;vehicle_color&#39;] != None:
                vehicle_config[&#39;vehicle_color&#39;] = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;)
            
            self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                             model_name = vehicle_config[&#34;model&#34;], 
                             choice = vehicle_config[&#39;choice&#39;], 
                             command = vehicle_config[&#39;command&#39;],
                             stop_choice = vehicle_config[&#39;stop_choice&#39;],
                             penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                             obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                             run = vehicle_config[&#39;run&#39;],
                             safety_distance = vehicle_config[&#39;safety_distance&#39;],
                             vehicle_color = vehicle_config[&#39;vehicle_color&#39;])
            
        for vehicle_config in intersection_settings[&#34;ahead_vehicle&#34;]:
            # add vehicles according to imported settings
            if vehicle_config[&#39;vehicle_color&#39;] != None:
                vehicle_config[&#39;vehicle_color&#39;] = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;)
            
            self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                             model_name = vehicle_config[&#34;model&#34;], 
                             choice = vehicle_config[&#39;choice&#39;], 
                             command = vehicle_config[&#39;command&#39;],
                             stop_choice = vehicle_config[&#39;stop_choice&#39;],
                             penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                             obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                             run = vehicle_config[&#39;run&#39;],
                             safety_distance = vehicle_config[&#39;safety_distance&#39;],
                             vehicle_color = vehicle_config[&#39;vehicle_color&#39;])
    
        self.light_config[&#39;subject&#39;] = intersection_settings[&#39;subject_light&#39;]
        self.light_config[&#39;subject_time&#39;] = intersection_settings[&#39;subject_light_time&#39;]
        
        self.light_config[&#39;left&#39;] = intersection_settings[&#39;left_light&#39;]
        self.light_config[&#39;left_time&#39;] = intersection_settings[&#39;left_light_time&#39;]
        
        self.light_config[&#39;right&#39;] = intersection_settings[&#39;right_light&#39;]
        self.light_config[&#39;right_time&#39;] = intersection_settings[&#39;right_light_time&#39;]
        
        self.light_config[&#39;ahead&#39;] = intersection_settings[&#39;ahead_light&#39;]
        self.light_config[&#39;ahead_time&#39;] = intersection_settings[&#39;ahead_light_time&#39;]
        
        new_intersection_setting = self.export_settings()
        return new_intersection_setting</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backend.intersection_definition.Intersection" href="intersection_definition.html#backend.intersection_definition.Intersection">Intersection</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="backend.initial_intersection.Init_Intersection.add_ego_vehicle"><code class="name flex">
<span>def <span class="ident">add_ego_vehicle</span></span>(<span>self, gap=10.0, model_name='vehicle.tesla.model3', stop_choice='abrupt', penetrate_distance=None, obey_traffic_lights=True, run=True, safety_distance=0.0, vehicle_color=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ego_vehicle(self, gap = 10.0,model_name = &#34;vehicle.tesla.model3&#34;, stop_choice = &#34;abrupt&#34;, penetrate_distance = None, obey_traffic_lights = True, run = True, safety_distance = 0.0, vehicle_color = None):
    
    self._add_full_path_vehicle(&#34;ego&#34;,gap = gap, model_name = model_name, obey_traffic_lights = obey_traffic_lights, run = run, safety_distance = safety_distance, vehicle_color = vehicle_color)
    self.ego_vehicle[&#34;lead_distance&#34;] = 0.0
    self.ego_vehicle[&#34;follow_distance&#34;] = 0.0
    self.ego_vehicle[&#34;index&#34;] = len(self.subject_vehicle) - 1 # the index of the ego vehicle in the subject
    self.ego_vehicle[&#34;vehicle_type&#34;] = &#34;ego&#34;
    self.ego_vehicle[&#34;stop_choice&#34;] = stop_choice
    self.ego_vehicle[&#34;penetrate_distance&#34;] = penetrate_distance
    self.ego_vehicle[&#34;stop_ref_point&#34;] = self._generate_full_path_stop_ref(stop_choice,penetrate_distance)
    
    return self.ego_vehicle[&#39;uniquename&#39;]</code></pre>
</details>
</dd>
<dt id="backend.initial_intersection.Init_Intersection.add_follow_vehicle"><code class="name flex">
<span>def <span class="ident">add_follow_vehicle</span></span>(<span>self, follow_distance, gap=10.0, model_name='vehicle.tesla.model3', stop_choice='abrupt', penetrate_distance=None, obey_traffic_lights=True, run=True, safety_distance=15.0, vehicle_color=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_follow_vehicle(self, follow_distance ,gap = 10.0,model_name = &#34;vehicle.tesla.model3&#34;, stop_choice = &#34;abrupt&#34;, penetrate_distance = None, obey_traffic_lights = True, run = True, safety_distance = 15.0, vehicle_color = None):
    # get all the vehicles that&#39;s going to be after the lead vehicle
    ego_index = self.ego_vehicle[&#34;index&#34;]
    vehicle_after_ego = self.subject_vehicle[ego_index + 1 : ]
    self.ego_vehicle[&#34;follow_distance&#34;] = follow_distance
    shift_distance = -(gap + 5) # should be gap + model length
    
    # shift all vehicles starting after the ego vehicle
    self._shift_vehicles(shift_distance,index = ego_index + 1)
    
    # only keep the vehicle until the ego 
    self.subject_vehicle = self.subject_vehicle[:ego_index + 1]
    
    # add the follow vehicle
    self._add_full_path_vehicle(&#34;follow&#34;,gap = gap, model_name = model_name, obey_traffic_lights = obey_traffic_lights, run = run, safety_distance = safety_distance, vehicle_color = vehicle_color)
    
    # put back vehicles after follow
    self.subject_vehicle += vehicle_after_ego
    

    self.follow_vehicle[&#34;vehicle_type&#34;] = &#34;follow&#34;
    
    # stop settings for follow vehicle
    self.follow_vehicle[&#34;stop_choice&#34;] = stop_choice
    self.follow_vehicle[&#34;penetrate_distance&#34;] = penetrate_distance
    self.follow_vehicle[&#34;stop_ref_point&#34;] = self._generate_full_path_stop_ref(stop_choice,penetrate_distance)
    return self.follow_vehicle[&#39;uniquename&#39;]</code></pre>
</details>
</dd>
<dt id="backend.initial_intersection.Init_Intersection.add_lead_vehicle"><code class="name flex">
<span>def <span class="ident">add_lead_vehicle</span></span>(<span>self, lead_distance, gap=10.0, model_name='vehicle.tesla.model3', stop_choice='abrupt', penetrate_distance=None, obey_traffic_lights=True, run=True, safety_distance=15.0, vehicle_color=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_lead_vehicle(self, lead_distance ,gap = 10.0,model_name = &#34;vehicle.tesla.model3&#34;, stop_choice = &#34;abrupt&#34;, penetrate_distance = None, obey_traffic_lights = True, run = True, safety_distance = 15.0, vehicle_color = None):
    # get all the vehicles that&#39;s going to be after the lead vehicle
    ego_index = self.ego_vehicle[&#34;index&#34;]
    vehicle_after_lead = self.subject_vehicle[ego_index : ]
    self.ego_vehicle[&#34;lead_distance&#34;] = lead_distance
    shift_distance = -(gap + 5) # should be gap + model length
    
    # shift all vehicles starting from the ego vehicle
    self._shift_vehicles(shift_distance,index = ego_index)
    
    # only keep the vehicle before the ego 
    self.subject_vehicle = self.subject_vehicle[:ego_index] 
    
    # add the lead vehicle
    self._add_full_path_vehicle(&#34;lead&#34;,gap = gap, model_name = model_name, obey_traffic_lights = obey_traffic_lights, run = run, safety_distance = safety_distance, vehicle_color = vehicle_color)

    # put back ego and vehicles after ego
    self.subject_vehicle += vehicle_after_lead
    
    # generate path for ego vehicle
    start_waypoint = self.ego_vehicle[&#34;ref_waypoint&#34;]
    trajectory, ref_speed_list = self._generate_full_path(start_waypoint)
    self.ego_vehicle[&#34;trajectory&#34;] = trajectory
    self.ego_vehicle[&#34;ref_speed_list&#34;] = ref_speed_list

    self.lead_vehicle[&#34;vehicle_type&#34;] = &#34;lead&#34;
    self.ego_vehicle[&#34;index&#34;] = ego_index + 1 # add one car in front of ego vehicle
    
    # stop settings for lead
    self.lead_vehicle[&#34;stop_choice&#34;] = stop_choice
    self.lead_vehicle[&#34;penetrate_distance&#34;] = penetrate_distance
    self.lead_vehicle[&#34;stop_ref_point&#34;] = self._generate_full_path_stop_ref(stop_choice,penetrate_distance)
    return self.lead_vehicle[&#39;uniquename&#39;]</code></pre>
</details>
</dd>
<dt id="backend.initial_intersection.Init_Intersection.export_settings"><code class="name flex">
<span>def <span class="ident">export_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>export all settings for a specific intersection
note: this method overrides the method in Intersection
by not exporting the settings for subject lane</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>intersection_settings</code></strong> :&ensp;<code>ConfigObj</code></dt>
<dd>settings of the intersection</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_settings(self):
    &#39;&#39;&#39;
    export all settings for a specific intersection
    note: this method overrides the method in Intersection
          by not exporting the settings for subject lane


    Returns
    -------
    intersection_settings : ConfigObj
        settings of the intersection

    &#39;&#39;&#39;
    intersection_settings = ConfigObj()
    
    # general
    intersection_settings[&#34;navigation_speed&#34;] = self.navigation_speed
    
    # vehicles
    intersection_settings[&#34;subject_vehicle&#34;] = []
    intersection_settings[&#34;left_vehicle&#34;] = []
    intersection_settings[&#34;right_vehicle&#34;] = []
    intersection_settings[&#34;ahead_vehicle&#34;] = []
    
    # do not export subject lane settings
    &#39;&#39;&#39;
    for vehicle in self.subject_vehicle:
        # deep copy the vehicle settings
        new_vehicle = self._copy_vehicle_settings(vehicle)
        intersection_settings[&#34;subject_vehicle&#34;].append(new_vehicle)
    &#39;&#39;&#39;
    
    for vehicle in self.left_vehicle:
        # deep copy the vehicle settings
        new_vehicle = self._copy_vehicle_settings(vehicle)
        intersection_settings[&#34;left_vehicle&#34;].append(new_vehicle)
        
    for vehicle in self.right_vehicle:
        # deep copy the vehicle settings
        new_vehicle = self._copy_vehicle_settings(vehicle)
        intersection_settings[&#34;right_vehicle&#34;].append(new_vehicle)
        
    for vehicle in self.ahead_vehicle:
        # deep copy the vehicle settings
        new_vehicle = self._copy_vehicle_settings(vehicle)
        intersection_settings[&#34;ahead_vehicle&#34;].append(new_vehicle)
    
    # lights
    intersection_settings[&#34;subject_light&#34;] = copy.copy(self.light_config[&#34;subject&#34;])
    intersection_settings[&#34;subject_light_time&#34;] = copy.copy(self.light_config[&#34;subject_time&#34;])
    
    intersection_settings[&#34;left_light&#34;] = copy.copy(self.light_config[&#34;left&#34;])
    intersection_settings[&#34;left_light_time&#34;] = copy.copy(self.light_config[&#34;left_time&#34;])
    
    intersection_settings[&#34;right_light&#34;] = copy.copy(self.light_config[&#34;right&#34;])
    intersection_settings[&#34;right_light_time&#34;] = copy.copy(self.light_config[&#34;right_time&#34;])
    
    intersection_settings[&#34;ahead_light&#34;] = copy.copy(self.light_config[&#34;ahead&#34;])
    intersection_settings[&#34;ahead_light_time&#34;] = copy.copy(self.light_config[&#34;ahead_time&#34;])
    
    return intersection_settings</code></pre>
</details>
</dd>
<dt id="backend.initial_intersection.Init_Intersection.import_settings"><code class="name flex">
<span>def <span class="ident">import_settings</span></span>(<span>self, intersection_settings)</span>
</code></dt>
<dd>
<div class="desc"><p>note: this method overrides the import_settings in Intersection
by add the part of removing the ego, lead and follow vehicle</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>intersection_settings</code></strong> :&ensp;<code>ConfigObj</code></dt>
<dd>the intersection settings we want to import</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>new_intersection_setting</code></strong> :&ensp;<code>ConfigObj</code></dt>
<dd>settings of the intersection
this will be generated by call self.export_settings() after finishing import
output these settings are for the purpose of creating the front-end gui</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_settings(self,intersection_settings):
    &#39;&#39;&#39;
    note: this method overrides the import_settings in Intersection
          by add the part of removing the ego, lead and follow vehicle
    
    Parameters
    ----------
    intersection_settings : ConfigObj
        the intersection settings we want to import

    Returns
    -------
    new_intersection_setting : ConfigObj
        settings of the intersection
        this will be generated by call self.export_settings() after finishing import
        output these settings are for the purpose of creating the front-end gui
    &#39;&#39;&#39;
    
    # remove ego, lead and follow settings 
    self.ego_vehicle = None
    self.lead_vehicle = None
    self.follow_vehicle = None
    
    # remove all vehicle in this intersection 
    # if any vehicle has been added
    for ii in range(len(self.subject_vehicle) - 1, -1, -1): # go through the array in reverse order
        uniquename = self.subject_vehicle[ii][&#39;uniquename&#39;]
        self.remove_vehicle(uniquename)
    
    for ii in range(len(self.left_vehicle) - 1, -1, -1): # go through the array in reverse order
        uniquename = self.left_vehicle[ii][&#39;uniquename&#39;]
        self.remove_vehicle(uniquename)
        
    for ii in range(len(self.right_vehicle) - 1, -1, -1): # go through the array in reverse order
        uniquename = self.right_vehicle[ii][&#39;uniquename&#39;]
        self.remove_vehicle(uniquename)
        
    for ii in range(len(self.ahead_vehicle) - 1, -1, -1): # go through the array in reverse order
        uniquename = self.ahead_vehicle[ii][&#39;uniquename&#39;]
        self.remove_vehicle(uniquename)
    
    # import all settings
   
    self.navigation_speed = float(intersection_settings[&#34;navigation_speed&#34;])
   
    &#39;&#39;&#39;
    for vehicle_config in intersection_settings[&#34;subject_vehicle&#34;]:
        # add vehicles according to imported settings
        self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                         model_name = vehicle_config[&#34;model&#34;], 
                         choice = vehicle_config[&#39;choice&#39;], 
                         command = vehicle_config[&#39;command&#39;],
                         stop_choice = vehicle_config[&#39;stop_choice&#39;],
                         penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                         obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                         run = vehicle_config[&#39;run&#39;],
                         safety_distance = vehicle_config[&#39;safety_distance&#39;],
                         vehicle_color = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;))
    &#39;&#39;&#39;
    
    for vehicle_config in intersection_settings[&#34;left_vehicle&#34;]:
        # add vehicles according to imported settings
        if vehicle_config[&#39;vehicle_color&#39;] != None:
            vehicle_config[&#39;vehicle_color&#39;] = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;)
        
        self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                         model_name = vehicle_config[&#34;model&#34;], 
                         choice = vehicle_config[&#39;choice&#39;], 
                         command = vehicle_config[&#39;command&#39;],
                         stop_choice = vehicle_config[&#39;stop_choice&#39;],
                         penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                         obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                         run = vehicle_config[&#39;run&#39;],
                         safety_distance = vehicle_config[&#39;safety_distance&#39;],
                         vehicle_color = vehicle_config[&#39;vehicle_color&#39;])
        
    for vehicle_config in intersection_settings[&#34;right_vehicle&#34;]:
        # add vehicles according to imported settings
        if vehicle_config[&#39;vehicle_color&#39;] != None:
            vehicle_config[&#39;vehicle_color&#39;] = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;)
        
        self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                         model_name = vehicle_config[&#34;model&#34;], 
                         choice = vehicle_config[&#39;choice&#39;], 
                         command = vehicle_config[&#39;command&#39;],
                         stop_choice = vehicle_config[&#39;stop_choice&#39;],
                         penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                         obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                         run = vehicle_config[&#39;run&#39;],
                         safety_distance = vehicle_config[&#39;safety_distance&#39;],
                         vehicle_color = vehicle_config[&#39;vehicle_color&#39;])
        
    for vehicle_config in intersection_settings[&#34;ahead_vehicle&#34;]:
        # add vehicles according to imported settings
        if vehicle_config[&#39;vehicle_color&#39;] != None:
            vehicle_config[&#39;vehicle_color&#39;] = vehicle_config[&#39;vehicle_color&#39;].replace(&#39;;&#39;,&#39;,&#39;)
        
        self.add_vehicle(gap = vehicle_config[&#34;gap&#34;], 
                         model_name = vehicle_config[&#34;model&#34;], 
                         choice = vehicle_config[&#39;choice&#39;], 
                         command = vehicle_config[&#39;command&#39;],
                         stop_choice = vehicle_config[&#39;stop_choice&#39;],
                         penetrate_distance = vehicle_config[&#39;penetrate_distance&#39;],
                         obey_traffic_lights = vehicle_config[&#39;obey_traffic_lights&#39;],
                         run = vehicle_config[&#39;run&#39;],
                         safety_distance = vehicle_config[&#39;safety_distance&#39;],
                         vehicle_color = vehicle_config[&#39;vehicle_color&#39;])

    self.light_config[&#39;subject&#39;] = intersection_settings[&#39;subject_light&#39;]
    self.light_config[&#39;subject_time&#39;] = intersection_settings[&#39;subject_light_time&#39;]
    
    self.light_config[&#39;left&#39;] = intersection_settings[&#39;left_light&#39;]
    self.light_config[&#39;left_time&#39;] = intersection_settings[&#39;left_light_time&#39;]
    
    self.light_config[&#39;right&#39;] = intersection_settings[&#39;right_light&#39;]
    self.light_config[&#39;right_time&#39;] = intersection_settings[&#39;right_light_time&#39;]
    
    self.light_config[&#39;ahead&#39;] = intersection_settings[&#39;ahead_light&#39;]
    self.light_config[&#39;ahead_time&#39;] = intersection_settings[&#39;ahead_light_time&#39;]
    
    new_intersection_setting = self.export_settings()
    return new_intersection_setting</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backend.intersection_definition.Intersection" href="intersection_definition.html#backend.intersection_definition.Intersection">Intersection</a></b></code>:
<ul class="hlist">
<li><code><a title="backend.intersection_definition.Intersection.add_vehicle" href="intersection_definition.html#backend.intersection_definition.Intersection.add_vehicle">add_vehicle</a></code></li>
<li><code><a title="backend.intersection_definition.Intersection.edit_traffic_light" href="intersection_definition.html#backend.intersection_definition.Intersection.edit_traffic_light">edit_traffic_light</a></code></li>
<li><code><a title="backend.intersection_definition.Intersection.edit_vehicle_settings" href="intersection_definition.html#backend.intersection_definition.Intersection.edit_vehicle_settings">edit_vehicle_settings</a></code></li>
<li><code><a title="backend.intersection_definition.Intersection.get_vehicle_bounding_box" href="intersection_definition.html#backend.intersection_definition.Intersection.get_vehicle_bounding_box">get_vehicle_bounding_box</a></code></li>
<li><code><a title="backend.intersection_definition.Intersection.get_vehicle_settings" href="intersection_definition.html#backend.intersection_definition.Intersection.get_vehicle_settings">get_vehicle_settings</a></code></li>
<li><code><a title="backend.intersection_definition.Intersection.remove_vehicle" href="intersection_definition.html#backend.intersection_definition.Intersection.remove_vehicle">remove_vehicle</a></code></li>
<li><code><a title="backend.intersection_definition.Intersection.start_simulation" href="intersection_definition.html#backend.intersection_definition.Intersection.start_simulation">start_simulation</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backend" href="index.html">backend</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="backend.initial_intersection.IntersectionBackend" href="#backend.initial_intersection.IntersectionBackend">IntersectionBackend</a></code></li>
<li><code><a title="backend.initial_intersection.create_intersections" href="#backend.initial_intersection.create_intersections">create_intersections</a></code></li>
<li><code><a title="backend.initial_intersection.get_ego_driving_spectator" href="#backend.initial_intersection.get_ego_driving_spectator">get_ego_driving_spectator</a></code></li>
<li><code><a title="backend.initial_intersection.get_ego_left_spectator" href="#backend.initial_intersection.get_ego_left_spectator">get_ego_left_spectator</a></code></li>
<li><code><a title="backend.initial_intersection.get_ego_spectator" href="#backend.initial_intersection.get_ego_spectator">get_ego_spectator</a></code></li>
<li><code><a title="backend.initial_intersection.main" href="#backend.initial_intersection.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backend.initial_intersection.Init_Intersection" href="#backend.initial_intersection.Init_Intersection">Init_Intersection</a></code></h4>
<ul class="">
<li><code><a title="backend.initial_intersection.Init_Intersection.add_ego_vehicle" href="#backend.initial_intersection.Init_Intersection.add_ego_vehicle">add_ego_vehicle</a></code></li>
<li><code><a title="backend.initial_intersection.Init_Intersection.add_follow_vehicle" href="#backend.initial_intersection.Init_Intersection.add_follow_vehicle">add_follow_vehicle</a></code></li>
<li><code><a title="backend.initial_intersection.Init_Intersection.add_lead_vehicle" href="#backend.initial_intersection.Init_Intersection.add_lead_vehicle">add_lead_vehicle</a></code></li>
<li><code><a title="backend.initial_intersection.Init_Intersection.export_settings" href="#backend.initial_intersection.Init_Intersection.export_settings">export_settings</a></code></li>
<li><code><a title="backend.initial_intersection.Init_Intersection.import_settings" href="#backend.initial_intersection.Init_Intersection.import_settings">import_settings</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>