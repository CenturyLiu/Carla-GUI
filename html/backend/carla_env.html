<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>backend.carla_env API documentation</title>
<meta name="description" content="Created on Sun May 24 13:45:54 2020 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backend.carla_env</code></h1>
</header>
<section id="section-intro">
<p>Created on Sun May 24 13:45:54 2020</p>
<p>@author: shijiliu</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Sun May 24 13:45:54 2020

@author: shijiliu
&#34;&#34;&#34;
import glob
import os
import sys
import time
import random

try:
    sys.path.append(glob.glob(&#39;../carla/dist/carla-*%d.%d-%s.egg&#39; % (
        sys.version_info.major,
        sys.version_info.minor,
        &#39;win-amd64&#39; if os.name == &#39;nt&#39; else &#39;linux-x86_64&#39;))[0])
except IndexError:
    pass



import carla
import matplotlib.pyplot as plt
import numpy as np
from collections import deque
from configobj import ConfigObj
import math

from sys import platform

# color for debug use
red = carla.Color(255, 0, 0)
green = carla.Color(0, 255, 0)
blue = carla.Color(47, 210, 231)
cyan = carla.Color(0, 255, 255)
yellow = carla.Color(255, 255, 0)
orange = carla.Color(255, 162, 0)
white = carla.Color(255, 255, 255)

def config_world(world, synchrony = True, delta_seconds = 0.02):
        &#39;&#39;&#39;
        Effects
        -------
        Config the carla world&#39;s synchrony and time-step
        tutorial: https://carla.readthedocs.io/en/latest/adv_synchrony_timestep/
        
        Parameters
        ----------
        synchrony : TYPE, optional
            DESCRIPTION. The default is True.
        delta_seconds : TYPE, optional
            DESCRIPTION. The default is 0.02.

        Returns
        -------
        synchrony, delta_seconds
        &#39;&#39;&#39;
        
        
        settings = world.get_settings()
        settings.synchronous_mode = synchrony
        settings.fixed_delta_seconds = delta_seconds
        world.apply_settings(settings)
        return synchrony, delta_seconds
        
class CARLA_ENV():
    def __init__(self, world):
        
        #self.client = carla.Client(&#39;localhost&#39;, 2000)
        #self.client.set_timeout(10.0)
        #self.client = client
        #self.world = self.client.get_world()
        self.world = world
        self.blueprint_library = self.world.get_blueprint_library()
        #self.blueprint_library = blueprint_library
        
        self.vehicle_dict = {}
        self.walker_dict = {}
        self.sensor_dict = {}
        self.config_env(synchrony = False)
        #self.synchrony = synchrony
        #self.delta_seconds = delta_seconds
        
        self.distance_between_vehicles = ConfigObj() # store the distance between vehicles
        
        # get the length of all vehicles


        vehicle_length_config_directory = os.path.join(&#39;backend&#39;, &#39;vehicle_length_config.txt&#39;)
        
        currentDirectory = os.path.join(os.path.dirname(os.getcwd()),  vehicle_length_config_directory)
        print(currentDirectory)
        self.vehicle_model_length_config = ConfigObj(currentDirectory)
        print(self.vehicle_model_length_config)
        

    def config_env(self, synchrony = False, delta_seconds = 0.02):
        
        self.synchrony = synchrony
        self.delta_seconds = delta_seconds
        settings = self.world.get_settings()
        settings.synchronous_mode = synchrony
        settings.fixed_delta_seconds = delta_seconds
        self.world.apply_settings(settings)
        
    def spawn_vehicle(self, model_name = None, spawn_point = None, color = None):
        &#39;&#39;&#39;
        Parameters
        ----------
        model_name : str TYPE, optional
            DESCRIPTION:  The default is None.
        spawn_point : carla.Transform() TYPE, optional
            DESCRIPTION. The default is None.
        color : str, optional
            the color of the vehicle

        Returns
        -------
        Uniquename of the actor.

        &#39;&#39;&#39;
        if model_name == None:
            bp = random.choice(self.blueprint_library.filter(&#39;vehicle.*.*&#39;))
        else:
            bp = random.choice(self.blueprint_library.filter(model_name))
        
        if spawn_point == None:
            spawn_point = random.choice(self.world.get_map().get_spawn_points())
        
        if color != None and bp.has_attribute(&#39;color&#39;):
            bp.set_attribute(&#39;color&#39;,color)
        
        
        vehicle = self.world.spawn_actor(bp,spawn_point)
        self.vehicle_dict[vehicle.type_id + &#39;_&#39; + str(vehicle.id)] = vehicle
        return vehicle.type_id + &#39;_&#39; + str(vehicle.id)
    
    def move_vehicle_location(self, uniquename, spawn_point):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : string
            uniquename of a vehicle.
        spawn_point :  carla.Transform()
            new spawn point of the vehicle

        Returns
        -------
        None.

        &#39;&#39;&#39;
        
        
        vehicle = self.vehicle_dict[uniquename]
        vehicle.set_transform(spawn_point)
    
    def destroy_vehicle(self, uniquename):
        if uniquename in self.vehicle_dict:
            self.vehicle_dict[uniquename].destroy() # destroy the vehicle in carla
            self.vehicle_dict.pop(uniquename) # remove the vehicle from dictionary
    
    def get_vehicle_model_length(self, model_name):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        model_name : string
            the model name of a vehicle model, or type_id of a vehicle

        Returns
        -------
        the length of the vehicle, or bounding_box.extent.x

        &#39;&#39;&#39;
        length = None
        if model_name in self.vehicle_model_length_config:
            length = float(self.vehicle_model_length_config[model_name])
        else:
            print(model_name)
            print(&#34;Error: invalid model_name entered to get vehicle model length&#34;)
        
        return length
    
    def get_vehicle_bounding_box(self, uniquename):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : string
            uniquename of a vehicle.

        Returns
        -------
        the carla actor corresponding to the uniquename.
        None type will be sent is uniquename doesn&#39;t exist
        

        &#39;&#39;&#39;
        ret_vehicle_bb = None
        if uniquename in self.vehicle_dict:
            ret_vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
            
            
        return ret_vehicle_bb
        
        
    def destroy_actors(self):
        &#39;&#39;&#39;
        Effects
        -------
        Destroy all actors that have been spawned

        Returns
        -------
        None.

        &#39;&#39;&#39;
        for index in self.vehicle_dict.keys():
            self.vehicle_dict[index].destroy()
        for index in self.walker_dict.keys():
            self.walker_dict[index].destroy()
        for index in self.sensor_dict.keys():
            self.sensor_dict[index].destroy()
            
        self.vehicle_dict.clear()
        self.walker_dict.clear()
        self.sensor_dict.clear()
        print(&#34;destroyed all actors&#34;)
        
    def apply_vehicle_control(self, uniquename, vehicle_control):
        &#39;&#39;&#39;
        Effects: apply control to a specific vehicle

        Parameters
        ----------
        uniquename : str TYPE
            DESCRIPTION.
        vehicle_control : vehicle control TYPE, https://carla.readthedocs.io/en/latest/python_api/#carla.Vehicle
            DESCRIPTION.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        vehicle.apply_control(vehicle_control)
        
    def set_vehicle_velocity(self, uniquename, vehicle_velocity):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : string
            uniquename of vehicle.
        vehicle_velocity : varla.Vector3D
            vehicle speed

        Returns
        -------
        None.

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        vehicle.set_target_velocity(vehicle_velocity)
        
        
    def get_forward_speed(self, uniquename):
        &#39;&#39;&#39;
        Get the forward speed of the vehicle

        Parameters
        ----------
        uniquename : TYPE
            name of the vehicle.

        Returns
        -------
        forward speed of the vehicle.

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        velocity = vehicle.get_velocity()
        return (velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2)**0.5
    
    def vehicle_available(self, uniquename):
        &#39;&#39;&#39;
        check whether the vehicle exists

        Parameters
        ----------
        uniquename : str
            name of the vehicle.

        Returns
        -------
        exists : bool
            whether the vehicle exists

        &#39;&#39;&#39;
        if uniquename in self.vehicle_dict:
            return True
        else:
            return False
    
    def get_transform_2d(self, uniquename):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle.

        Returns
        -------
        location and orientation of the vehicle.

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        transform = vehicle.get_transform()
        location_2d = [transform.location.x, transform.location.y]
        yaw = transform.rotation.yaw
        
        return (location_2d,yaw)
    
    def get_transform_3d(self, uniquename):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle.

        Returns
        -------
        3d transform of the vehicle

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        transform = vehicle.get_transform()
        
        
        return transform
    
    def update_vehicle_distance(self):
        &#39;&#39;&#39;
        Update the distance between each 2 vehicles
        This function should be called each world.tick()

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.distance_between_vehicles.reset() # reset the configuration file each update
        
        # get all available vehicles
        vehicle_uniquenames = []
        for name in self.vehicle_dict:
            vehicle_uniquenames.append(name)
            self.distance_between_vehicles[name] = {} # create empty storage
            
        for ii in range(len(vehicle_uniquenames)):
            for jj in range(ii,len(vehicle_uniquenames)):
                name_1 = vehicle_uniquenames[ii]
                name_2 = vehicle_uniquenames[jj]
                if name_1 == name_2:
                    self.distance_between_vehicles[name_1][name_2] = 0.0 # distance with itself, 0.0
                else:
                    vehicle_1 = self.vehicle_dict[name_1]
                    vehicle_2 = self.vehicle_dict[name_2]
                    location_1 = vehicle_1.get_transform().location
                    location_2 = vehicle_2.get_transform().location
                    distance = math.sqrt((location_1.x - location_2.x)**2 + (location_1.y - location_2.y)**2)
                    self.distance_between_vehicles[name_1][name_2] = distance
                    self.distance_between_vehicles[name_2][name_1] = distance
                    
    def check_vehicle_in_front(self, uniquename, safety_distance):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle.
            
        safety_distance: float
            allowed closest distance between two vehicles

        Returns
        -------
        has_vehicle_in_front : bool
            whether there exists a vehicle within safety distance
        distance: float
            distance between this vehicle and the vehicle in the front

        &#39;&#39;&#39;
        # get the distance between this vehicle and other vehicles
        distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
        
        # get the bounding box of this vehicle
        vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
        safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
        
        has_vehicle_in_front = False
        distance = None
        
        vehicle_1 = self.vehicle_dict[uniquename]
        location_1 = vehicle_1.get_transform().location
        forward_vector = vehicle_1.get_transform().get_forward_vector()
        
        for name in distance_with_other_vehicle:
            if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
                location_2 = self.vehicle_dict[name].get_transform().location
                vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
                forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
                
                norm_vec1_2 = vec1_2 / np.linalg.norm(vec1_2)
                norm_forward_vector_2d = forward_vector_2d / np.linalg.norm(forward_vector_2d)
                dot_product = np.dot(norm_vec1_2,norm_forward_vector_2d)
                angle = np.arccos(dot_product)
                
                
                
                if angle &lt; np.arctan(vehicle_bb.y /  vehicle_bb.x):#np.arcsin((vehicle_bb.y  + 1) / distance_with_other_vehicle[name]):#np.arctan(vehicle_bb.y / vehicle_bb.x): 
                    has_vehicle_in_front = True
                    distance = np.dot(vec1_2,forward_vector_2d)
                    break
            
        return has_vehicle_in_front, distance
    
    def check_vehicle_in_front_freeway(self, uniquename, safety_distance):
        &#39;&#39;&#39;
        greatly narrow the front view for freeway
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle.
            
        safety_distance: float
            allowed closest distance between two vehicles

        Returns
        -------
        has_vehicle_in_front : bool
            whether there exists a vehicle within safety distance
        distance: float
            distance between this vehicle and the vehicle in the front

        &#39;&#39;&#39;
        # get the distance between this vehicle and other vehicles
        distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
        
        # get the bounding box of this vehicle
        vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
        safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
        
        has_vehicle_in_front = False
        distance = None
        
        vehicle_1 = self.vehicle_dict[uniquename]
        location_1 = vehicle_1.get_transform().location
        forward_vector = vehicle_1.get_transform().get_forward_vector()
        
        for name in distance_with_other_vehicle:
            if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
                location_2 = self.vehicle_dict[name].get_transform().location
                vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
                forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
                
                norm_vec1_2 = vec1_2 / np.linalg.norm(vec1_2)
                norm_forward_vector_2d = forward_vector_2d / np.linalg.norm(forward_vector_2d)
                dot_product = np.dot(norm_vec1_2,norm_forward_vector_2d)
                angle = np.arccos(dot_product)
                
                
                
                if angle &lt; np.pi / 36:#np.arcsin((vehicle_bb.y  / 2) / distance_with_other_vehicle[name]):#np.arcsin((vehicle_bb.y  + 1) / distance_with_other_vehicle[name]):#np.arctan(vehicle_bb.y / vehicle_bb.x): 
                    has_vehicle_in_front = True
                    distance = np.dot(vec1_2,forward_vector_2d)
                    break
            
        return has_vehicle_in_front, distance
    
    def check_vehicle_in_back_freeway(self, uniquename, safety_distance):
        &#39;&#39;&#39;
        
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle.
            
        safety_distance: float
            allowed closest distance between two vehicles

        Returns
        -------
        has_vehicle_in_back : bool
            whether there exists a vehicle within safety distance
        distance: float
            distance between this vehicle and the vehicle in the front

        &#39;&#39;&#39;
        # get the distance between this vehicle and other vehicles
        distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
        
        # get the bounding box of this vehicle
        vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
        safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
        
        has_vehicle_in_back = False
        distance = None
        smallest_distance = np.inf
        
        vehicle_1 = self.vehicle_dict[uniquename]
        location_1 = vehicle_1.get_transform().location
        forward_vector = vehicle_1.get_transform().get_forward_vector()
        
        for name in distance_with_other_vehicle:
            if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
                location_2 = self.vehicle_dict[name].get_transform().location
                vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
                forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
                
                norm_vec1_2 = vec1_2 / np.linalg.norm(vec1_2)
                norm_forward_vector_2d = forward_vector_2d / np.linalg.norm(forward_vector_2d)
                dot_product = np.dot(norm_vec1_2,norm_forward_vector_2d)
                angle = np.arccos(dot_product)
                
                
                
                if angle &gt; np.pi - np.arcsin((vehicle_bb.y  / 2) / distance_with_other_vehicle[name]):#np.arcsin((vehicle_bb.y  + 1) / distance_with_other_vehicle[name]):#np.arctan(vehicle_bb.y / vehicle_bb.x): 
                    has_vehicle_in_back = True
                    distance = np.dot(vec1_2,forward_vector_2d)
                    if abs(distance) &lt; abs(smallest_distance):
                        smallest_distance = distance
            
        return has_vehicle_in_back, smallest_distance
        
    def check_vehicle_in_right(self, uniquename, safety_distance = 6):
        &#39;&#39;&#39;
        function checking whether a right vehicle is too close to the current vehicle
        this function is primarily designed to help decide whether a vehicle can safely change lane

        Parameters
        ----------
        uniquename : str
            name of the vehicle.
            
        safety_distance: float
            allowed closest distance between two vehicles

        Returns
        -------
        has_vehicle_in_right : bool
            whether there exists a vehicle within safety distance
        distance: float
            distance between this vehicle and the vehicle to the right

        &#39;&#39;&#39;
        # get the distance between this vehicle and other vehicles
        distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
        
        # get the bounding box of this vehicle
        vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
        safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
        
        has_vehicle_in_right = False
        distance = None
        
        smallest_distance = np.inf
        
        vehicle_1 = self.vehicle_dict[uniquename]
        location_1 = vehicle_1.get_transform().location
        forward_vector = vehicle_1.get_transform().get_forward_vector()
        forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
        forward_vector_3d = np.array([forward_vector.x, forward_vector.y, 0])
        
        for name in distance_with_other_vehicle:
            if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
                print(distance_with_other_vehicle[name])
            
                location_2 = self.vehicle_dict[name].get_transform().location
                vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y, 0])
                vec1_2_2d = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
                cross_product = np.cross(forward_vector_3d, vec1_2)
                if cross_product[2] &gt; 0: # left hand system
                    has_vehicle_in_right = True
                    distance = np.dot(forward_vector_2d, vec1_2_2d)
                    if abs(distance) &lt;= smallest_distance:
                        smallest_distance = distance
                    
                
        return has_vehicle_in_right, smallest_distance

    def check_vehicle_in_left(self, uniquename, safety_distance = 6):
        &#39;&#39;&#39;
        function checking whether a left vehicle is too close to the current vehicle
        this function is primarily designed to help decide whether a vehicle can safely change lane

        Parameters
        ----------
        uniquename : str
            name of the vehicle.
            
        safety_distance: float
            allowed closest distance between two vehicles

        Returns
        -------
        has_vehicle_in_left : bool
            whether there exists a vehicle within safety distance
        distance: float
            distance between this vehicle and the vehicle to the right

        &#39;&#39;&#39;
        # get the distance between this vehicle and other vehicles
        distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
        
        # get the bounding box of this vehicle
        vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
        safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
        
        has_vehicle_in_left = False
        distance = None
        smallest_distance = np.inf
        
        vehicle_1 = self.vehicle_dict[uniquename]
        location_1 = vehicle_1.get_transform().location
        forward_vector = vehicle_1.get_transform().get_forward_vector()
        forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
        forward_vector_3d = np.array([forward_vector.x, forward_vector.y, 0])
        
        for name in distance_with_other_vehicle:
            if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
                print(distance_with_other_vehicle[name])    
            
                location_2 = self.vehicle_dict[name].get_transform().location
                vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y, 0])
                vec1_2_2d = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
                cross_product = np.cross(forward_vector_3d, vec1_2)
                if cross_product[2] &lt; 0: # this is the only difference between the check_vehicle_in_left / check_vehicle_in_right function 
                    has_vehicle_in_left = True
                    distance = np.dot(forward_vector_2d, vec1_2_2d)
                    if abs(distance) &lt;= smallest_distance:
                        smallest_distance = distance
                
        return has_vehicle_in_left, smallest_distance

    
    def get_traffic_light_state(self, uniquename):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle..

        Returns
        -------
        The traffic light state corresponding to this vehicle.
        If no traffic light available, return None

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        state = None
        if vehicle.is_at_traffic_light():
            light = vehicle.get_traffic_light()
            state = light.get_state()
            
        return state
        
    def draw_waypoints(self, trajectory, points):
        &#39;&#39;&#39;
        Draw the way points and trajectory for the vehicle to follow

        Parameters
        ----------
        trajectory : numpy 2d array
            the interpolated trajectory of a vehicle.
        points : list of (x,y)
            waypoints to highlight

        Returns
        -------
        None.

        &#39;&#39;&#39;
        for ii in range(len(points) - 1):
            location = carla.Location(x = points[ii][0], y = points[ii][1], z = 5.0)
            self.world.debug.draw_point(location, size = 0.1, color = orange, life_time=0.0, persistent_lines=True)
        
        location = carla.Location(x = points[-1][0], y = points[-1][1], z = 5.0)
        self.world.debug.draw_point(location, size = 0.1, color = red, life_time=0.0, persistent_lines=True)
        
        for ii in range(1,len(trajectory)):
            begin = carla.Location(x = trajectory[ii - 1][0], y = trajectory[ii - 1][1], z = 5.0)
            end = carla.Location(x = trajectory[ii][0], y = trajectory[ii][1], z = 5.0)
            self.world.debug.draw_line(begin, end, thickness=0.8, color=orange, life_time=0.0, persistent_lines=True)
    
    def draw_real_trajectory(self, real_trajectory):
        &#39;&#39;&#39;
        Draw the real trajectory

        Parameters
        ----------
        real_trajectory : a deque of 2 (x,y) tuple
            stores the current and previous 2d location of the vehicle

        Returns
        -------
        None.

        &#39;&#39;&#39;
        begin = carla.Location(x = real_trajectory[0][0], y = real_trajectory[0][1], z = 5.0)
        end = carla.Location(x = real_trajectory[1][0], y = real_trajectory[1][1], z = 5.0)
        #self.world.debug.draw_arrow(begin, end, thickness=1.0, arrow_size=1.0, color = green, life_time=0.0, persistent_lines=True)
        
&#39;&#39;&#39;
client = carla.Client(&#34;localhost&#34;,2000)
client.set_timeout(2.0)
world = client.load_world(&#39;Town03&#39;)#&#39;Town06&#39; for plain ground
weather = carla.WeatherParameters(
    cloudiness=10.0,
    precipitation=0.0,
    sun_altitude_angle=90.0)
world.set_weather(weather)
&#39;&#39;&#39;
&#39;&#39;&#39;
settings = world.get_settings()
#settings.synchronous_mode = True
settings.fixed_delta_seconds = 0.02
world.apply_settings(settings)

settings = world.get_settings()
settings.synchronous_mode = True
world.apply_settings(settings)

#synchrony, delta_seconds = config_world(world)
blueprint_library = world.get_blueprint_library()
&#39;&#39;&#39;
&#39;&#39;&#39;
env = CARLA_ENV(world)

try:
    name = env.spawn_vehicle()
    print(name)
finally:
    env.destroy_actors()
&#39;&#39;&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="backend.carla_env.config_world"><code class="name flex">
<span>def <span class="ident">config_world</span></span>(<span>world, synchrony=True, delta_seconds=0.02)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="effects">Effects</h2>
<p>Config the carla world's synchrony and time-step
tutorial: <a href="https://carla.readthedocs.io/en/latest/adv_synchrony_timestep/">https://carla.readthedocs.io/en/latest/adv_synchrony_timestep/</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>synchrony</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is True.</dd>
<dt><strong><code>delta_seconds</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 0.02.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>synchrony, delta_seconds</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_world(world, synchrony = True, delta_seconds = 0.02):
        &#39;&#39;&#39;
        Effects
        -------
        Config the carla world&#39;s synchrony and time-step
        tutorial: https://carla.readthedocs.io/en/latest/adv_synchrony_timestep/
        
        Parameters
        ----------
        synchrony : TYPE, optional
            DESCRIPTION. The default is True.
        delta_seconds : TYPE, optional
            DESCRIPTION. The default is 0.02.

        Returns
        -------
        synchrony, delta_seconds
        &#39;&#39;&#39;
        
        
        settings = world.get_settings()
        settings.synchronous_mode = synchrony
        settings.fixed_delta_seconds = delta_seconds
        world.apply_settings(settings)
        return synchrony, delta_seconds</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backend.carla_env.CARLA_ENV"><code class="flex name class">
<span>class <span class="ident">CARLA_ENV</span></span>
<span>(</span><span>world)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CARLA_ENV():
    def __init__(self, world):
        
        #self.client = carla.Client(&#39;localhost&#39;, 2000)
        #self.client.set_timeout(10.0)
        #self.client = client
        #self.world = self.client.get_world()
        self.world = world
        self.blueprint_library = self.world.get_blueprint_library()
        #self.blueprint_library = blueprint_library
        
        self.vehicle_dict = {}
        self.walker_dict = {}
        self.sensor_dict = {}
        self.config_env(synchrony = False)
        #self.synchrony = synchrony
        #self.delta_seconds = delta_seconds
        
        self.distance_between_vehicles = ConfigObj() # store the distance between vehicles
        
        # get the length of all vehicles


        vehicle_length_config_directory = os.path.join(&#39;backend&#39;, &#39;vehicle_length_config.txt&#39;)
        
        currentDirectory = os.path.join(os.path.dirname(os.getcwd()),  vehicle_length_config_directory)
        print(currentDirectory)
        self.vehicle_model_length_config = ConfigObj(currentDirectory)
        print(self.vehicle_model_length_config)
        

    def config_env(self, synchrony = False, delta_seconds = 0.02):
        
        self.synchrony = synchrony
        self.delta_seconds = delta_seconds
        settings = self.world.get_settings()
        settings.synchronous_mode = synchrony
        settings.fixed_delta_seconds = delta_seconds
        self.world.apply_settings(settings)
        
    def spawn_vehicle(self, model_name = None, spawn_point = None, color = None):
        &#39;&#39;&#39;
        Parameters
        ----------
        model_name : str TYPE, optional
            DESCRIPTION:  The default is None.
        spawn_point : carla.Transform() TYPE, optional
            DESCRIPTION. The default is None.
        color : str, optional
            the color of the vehicle

        Returns
        -------
        Uniquename of the actor.

        &#39;&#39;&#39;
        if model_name == None:
            bp = random.choice(self.blueprint_library.filter(&#39;vehicle.*.*&#39;))
        else:
            bp = random.choice(self.blueprint_library.filter(model_name))
        
        if spawn_point == None:
            spawn_point = random.choice(self.world.get_map().get_spawn_points())
        
        if color != None and bp.has_attribute(&#39;color&#39;):
            bp.set_attribute(&#39;color&#39;,color)
        
        
        vehicle = self.world.spawn_actor(bp,spawn_point)
        self.vehicle_dict[vehicle.type_id + &#39;_&#39; + str(vehicle.id)] = vehicle
        return vehicle.type_id + &#39;_&#39; + str(vehicle.id)
    
    def move_vehicle_location(self, uniquename, spawn_point):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : string
            uniquename of a vehicle.
        spawn_point :  carla.Transform()
            new spawn point of the vehicle

        Returns
        -------
        None.

        &#39;&#39;&#39;
        
        
        vehicle = self.vehicle_dict[uniquename]
        vehicle.set_transform(spawn_point)
    
    def destroy_vehicle(self, uniquename):
        if uniquename in self.vehicle_dict:
            self.vehicle_dict[uniquename].destroy() # destroy the vehicle in carla
            self.vehicle_dict.pop(uniquename) # remove the vehicle from dictionary
    
    def get_vehicle_model_length(self, model_name):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        model_name : string
            the model name of a vehicle model, or type_id of a vehicle

        Returns
        -------
        the length of the vehicle, or bounding_box.extent.x

        &#39;&#39;&#39;
        length = None
        if model_name in self.vehicle_model_length_config:
            length = float(self.vehicle_model_length_config[model_name])
        else:
            print(model_name)
            print(&#34;Error: invalid model_name entered to get vehicle model length&#34;)
        
        return length
    
    def get_vehicle_bounding_box(self, uniquename):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : string
            uniquename of a vehicle.

        Returns
        -------
        the carla actor corresponding to the uniquename.
        None type will be sent is uniquename doesn&#39;t exist
        

        &#39;&#39;&#39;
        ret_vehicle_bb = None
        if uniquename in self.vehicle_dict:
            ret_vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
            
            
        return ret_vehicle_bb
        
        
    def destroy_actors(self):
        &#39;&#39;&#39;
        Effects
        -------
        Destroy all actors that have been spawned

        Returns
        -------
        None.

        &#39;&#39;&#39;
        for index in self.vehicle_dict.keys():
            self.vehicle_dict[index].destroy()
        for index in self.walker_dict.keys():
            self.walker_dict[index].destroy()
        for index in self.sensor_dict.keys():
            self.sensor_dict[index].destroy()
            
        self.vehicle_dict.clear()
        self.walker_dict.clear()
        self.sensor_dict.clear()
        print(&#34;destroyed all actors&#34;)
        
    def apply_vehicle_control(self, uniquename, vehicle_control):
        &#39;&#39;&#39;
        Effects: apply control to a specific vehicle

        Parameters
        ----------
        uniquename : str TYPE
            DESCRIPTION.
        vehicle_control : vehicle control TYPE, https://carla.readthedocs.io/en/latest/python_api/#carla.Vehicle
            DESCRIPTION.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        vehicle.apply_control(vehicle_control)
        
    def set_vehicle_velocity(self, uniquename, vehicle_velocity):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : string
            uniquename of vehicle.
        vehicle_velocity : varla.Vector3D
            vehicle speed

        Returns
        -------
        None.

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        vehicle.set_target_velocity(vehicle_velocity)
        
        
    def get_forward_speed(self, uniquename):
        &#39;&#39;&#39;
        Get the forward speed of the vehicle

        Parameters
        ----------
        uniquename : TYPE
            name of the vehicle.

        Returns
        -------
        forward speed of the vehicle.

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        velocity = vehicle.get_velocity()
        return (velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2)**0.5
    
    def vehicle_available(self, uniquename):
        &#39;&#39;&#39;
        check whether the vehicle exists

        Parameters
        ----------
        uniquename : str
            name of the vehicle.

        Returns
        -------
        exists : bool
            whether the vehicle exists

        &#39;&#39;&#39;
        if uniquename in self.vehicle_dict:
            return True
        else:
            return False
    
    def get_transform_2d(self, uniquename):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle.

        Returns
        -------
        location and orientation of the vehicle.

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        transform = vehicle.get_transform()
        location_2d = [transform.location.x, transform.location.y]
        yaw = transform.rotation.yaw
        
        return (location_2d,yaw)
    
    def get_transform_3d(self, uniquename):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle.

        Returns
        -------
        3d transform of the vehicle

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        transform = vehicle.get_transform()
        
        
        return transform
    
    def update_vehicle_distance(self):
        &#39;&#39;&#39;
        Update the distance between each 2 vehicles
        This function should be called each world.tick()

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.distance_between_vehicles.reset() # reset the configuration file each update
        
        # get all available vehicles
        vehicle_uniquenames = []
        for name in self.vehicle_dict:
            vehicle_uniquenames.append(name)
            self.distance_between_vehicles[name] = {} # create empty storage
            
        for ii in range(len(vehicle_uniquenames)):
            for jj in range(ii,len(vehicle_uniquenames)):
                name_1 = vehicle_uniquenames[ii]
                name_2 = vehicle_uniquenames[jj]
                if name_1 == name_2:
                    self.distance_between_vehicles[name_1][name_2] = 0.0 # distance with itself, 0.0
                else:
                    vehicle_1 = self.vehicle_dict[name_1]
                    vehicle_2 = self.vehicle_dict[name_2]
                    location_1 = vehicle_1.get_transform().location
                    location_2 = vehicle_2.get_transform().location
                    distance = math.sqrt((location_1.x - location_2.x)**2 + (location_1.y - location_2.y)**2)
                    self.distance_between_vehicles[name_1][name_2] = distance
                    self.distance_between_vehicles[name_2][name_1] = distance
                    
    def check_vehicle_in_front(self, uniquename, safety_distance):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle.
            
        safety_distance: float
            allowed closest distance between two vehicles

        Returns
        -------
        has_vehicle_in_front : bool
            whether there exists a vehicle within safety distance
        distance: float
            distance between this vehicle and the vehicle in the front

        &#39;&#39;&#39;
        # get the distance between this vehicle and other vehicles
        distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
        
        # get the bounding box of this vehicle
        vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
        safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
        
        has_vehicle_in_front = False
        distance = None
        
        vehicle_1 = self.vehicle_dict[uniquename]
        location_1 = vehicle_1.get_transform().location
        forward_vector = vehicle_1.get_transform().get_forward_vector()
        
        for name in distance_with_other_vehicle:
            if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
                location_2 = self.vehicle_dict[name].get_transform().location
                vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
                forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
                
                norm_vec1_2 = vec1_2 / np.linalg.norm(vec1_2)
                norm_forward_vector_2d = forward_vector_2d / np.linalg.norm(forward_vector_2d)
                dot_product = np.dot(norm_vec1_2,norm_forward_vector_2d)
                angle = np.arccos(dot_product)
                
                
                
                if angle &lt; np.arctan(vehicle_bb.y /  vehicle_bb.x):#np.arcsin((vehicle_bb.y  + 1) / distance_with_other_vehicle[name]):#np.arctan(vehicle_bb.y / vehicle_bb.x): 
                    has_vehicle_in_front = True
                    distance = np.dot(vec1_2,forward_vector_2d)
                    break
            
        return has_vehicle_in_front, distance
    
    def check_vehicle_in_front_freeway(self, uniquename, safety_distance):
        &#39;&#39;&#39;
        greatly narrow the front view for freeway
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle.
            
        safety_distance: float
            allowed closest distance between two vehicles

        Returns
        -------
        has_vehicle_in_front : bool
            whether there exists a vehicle within safety distance
        distance: float
            distance between this vehicle and the vehicle in the front

        &#39;&#39;&#39;
        # get the distance between this vehicle and other vehicles
        distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
        
        # get the bounding box of this vehicle
        vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
        safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
        
        has_vehicle_in_front = False
        distance = None
        
        vehicle_1 = self.vehicle_dict[uniquename]
        location_1 = vehicle_1.get_transform().location
        forward_vector = vehicle_1.get_transform().get_forward_vector()
        
        for name in distance_with_other_vehicle:
            if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
                location_2 = self.vehicle_dict[name].get_transform().location
                vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
                forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
                
                norm_vec1_2 = vec1_2 / np.linalg.norm(vec1_2)
                norm_forward_vector_2d = forward_vector_2d / np.linalg.norm(forward_vector_2d)
                dot_product = np.dot(norm_vec1_2,norm_forward_vector_2d)
                angle = np.arccos(dot_product)
                
                
                
                if angle &lt; np.pi / 36:#np.arcsin((vehicle_bb.y  / 2) / distance_with_other_vehicle[name]):#np.arcsin((vehicle_bb.y  + 1) / distance_with_other_vehicle[name]):#np.arctan(vehicle_bb.y / vehicle_bb.x): 
                    has_vehicle_in_front = True
                    distance = np.dot(vec1_2,forward_vector_2d)
                    break
            
        return has_vehicle_in_front, distance
    
    def check_vehicle_in_back_freeway(self, uniquename, safety_distance):
        &#39;&#39;&#39;
        
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle.
            
        safety_distance: float
            allowed closest distance between two vehicles

        Returns
        -------
        has_vehicle_in_back : bool
            whether there exists a vehicle within safety distance
        distance: float
            distance between this vehicle and the vehicle in the front

        &#39;&#39;&#39;
        # get the distance between this vehicle and other vehicles
        distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
        
        # get the bounding box of this vehicle
        vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
        safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
        
        has_vehicle_in_back = False
        distance = None
        smallest_distance = np.inf
        
        vehicle_1 = self.vehicle_dict[uniquename]
        location_1 = vehicle_1.get_transform().location
        forward_vector = vehicle_1.get_transform().get_forward_vector()
        
        for name in distance_with_other_vehicle:
            if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
                location_2 = self.vehicle_dict[name].get_transform().location
                vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
                forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
                
                norm_vec1_2 = vec1_2 / np.linalg.norm(vec1_2)
                norm_forward_vector_2d = forward_vector_2d / np.linalg.norm(forward_vector_2d)
                dot_product = np.dot(norm_vec1_2,norm_forward_vector_2d)
                angle = np.arccos(dot_product)
                
                
                
                if angle &gt; np.pi - np.arcsin((vehicle_bb.y  / 2) / distance_with_other_vehicle[name]):#np.arcsin((vehicle_bb.y  + 1) / distance_with_other_vehicle[name]):#np.arctan(vehicle_bb.y / vehicle_bb.x): 
                    has_vehicle_in_back = True
                    distance = np.dot(vec1_2,forward_vector_2d)
                    if abs(distance) &lt; abs(smallest_distance):
                        smallest_distance = distance
            
        return has_vehicle_in_back, smallest_distance
        
    def check_vehicle_in_right(self, uniquename, safety_distance = 6):
        &#39;&#39;&#39;
        function checking whether a right vehicle is too close to the current vehicle
        this function is primarily designed to help decide whether a vehicle can safely change lane

        Parameters
        ----------
        uniquename : str
            name of the vehicle.
            
        safety_distance: float
            allowed closest distance between two vehicles

        Returns
        -------
        has_vehicle_in_right : bool
            whether there exists a vehicle within safety distance
        distance: float
            distance between this vehicle and the vehicle to the right

        &#39;&#39;&#39;
        # get the distance between this vehicle and other vehicles
        distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
        
        # get the bounding box of this vehicle
        vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
        safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
        
        has_vehicle_in_right = False
        distance = None
        
        smallest_distance = np.inf
        
        vehicle_1 = self.vehicle_dict[uniquename]
        location_1 = vehicle_1.get_transform().location
        forward_vector = vehicle_1.get_transform().get_forward_vector()
        forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
        forward_vector_3d = np.array([forward_vector.x, forward_vector.y, 0])
        
        for name in distance_with_other_vehicle:
            if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
                print(distance_with_other_vehicle[name])
            
                location_2 = self.vehicle_dict[name].get_transform().location
                vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y, 0])
                vec1_2_2d = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
                cross_product = np.cross(forward_vector_3d, vec1_2)
                if cross_product[2] &gt; 0: # left hand system
                    has_vehicle_in_right = True
                    distance = np.dot(forward_vector_2d, vec1_2_2d)
                    if abs(distance) &lt;= smallest_distance:
                        smallest_distance = distance
                    
                
        return has_vehicle_in_right, smallest_distance

    def check_vehicle_in_left(self, uniquename, safety_distance = 6):
        &#39;&#39;&#39;
        function checking whether a left vehicle is too close to the current vehicle
        this function is primarily designed to help decide whether a vehicle can safely change lane

        Parameters
        ----------
        uniquename : str
            name of the vehicle.
            
        safety_distance: float
            allowed closest distance between two vehicles

        Returns
        -------
        has_vehicle_in_left : bool
            whether there exists a vehicle within safety distance
        distance: float
            distance between this vehicle and the vehicle to the right

        &#39;&#39;&#39;
        # get the distance between this vehicle and other vehicles
        distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
        
        # get the bounding box of this vehicle
        vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
        safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
        
        has_vehicle_in_left = False
        distance = None
        smallest_distance = np.inf
        
        vehicle_1 = self.vehicle_dict[uniquename]
        location_1 = vehicle_1.get_transform().location
        forward_vector = vehicle_1.get_transform().get_forward_vector()
        forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
        forward_vector_3d = np.array([forward_vector.x, forward_vector.y, 0])
        
        for name in distance_with_other_vehicle:
            if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
                print(distance_with_other_vehicle[name])    
            
                location_2 = self.vehicle_dict[name].get_transform().location
                vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y, 0])
                vec1_2_2d = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
                cross_product = np.cross(forward_vector_3d, vec1_2)
                if cross_product[2] &lt; 0: # this is the only difference between the check_vehicle_in_left / check_vehicle_in_right function 
                    has_vehicle_in_left = True
                    distance = np.dot(forward_vector_2d, vec1_2_2d)
                    if abs(distance) &lt;= smallest_distance:
                        smallest_distance = distance
                
        return has_vehicle_in_left, smallest_distance

    
    def get_traffic_light_state(self, uniquename):
        &#39;&#39;&#39;
        

        Parameters
        ----------
        uniquename : str
            name of the vehicle..

        Returns
        -------
        The traffic light state corresponding to this vehicle.
        If no traffic light available, return None

        &#39;&#39;&#39;
        vehicle = self.vehicle_dict[uniquename]
        state = None
        if vehicle.is_at_traffic_light():
            light = vehicle.get_traffic_light()
            state = light.get_state()
            
        return state
        
    def draw_waypoints(self, trajectory, points):
        &#39;&#39;&#39;
        Draw the way points and trajectory for the vehicle to follow

        Parameters
        ----------
        trajectory : numpy 2d array
            the interpolated trajectory of a vehicle.
        points : list of (x,y)
            waypoints to highlight

        Returns
        -------
        None.

        &#39;&#39;&#39;
        for ii in range(len(points) - 1):
            location = carla.Location(x = points[ii][0], y = points[ii][1], z = 5.0)
            self.world.debug.draw_point(location, size = 0.1, color = orange, life_time=0.0, persistent_lines=True)
        
        location = carla.Location(x = points[-1][0], y = points[-1][1], z = 5.0)
        self.world.debug.draw_point(location, size = 0.1, color = red, life_time=0.0, persistent_lines=True)
        
        for ii in range(1,len(trajectory)):
            begin = carla.Location(x = trajectory[ii - 1][0], y = trajectory[ii - 1][1], z = 5.0)
            end = carla.Location(x = trajectory[ii][0], y = trajectory[ii][1], z = 5.0)
            self.world.debug.draw_line(begin, end, thickness=0.8, color=orange, life_time=0.0, persistent_lines=True)
    
    def draw_real_trajectory(self, real_trajectory):
        &#39;&#39;&#39;
        Draw the real trajectory

        Parameters
        ----------
        real_trajectory : a deque of 2 (x,y) tuple
            stores the current and previous 2d location of the vehicle

        Returns
        -------
        None.

        &#39;&#39;&#39;
        begin = carla.Location(x = real_trajectory[0][0], y = real_trajectory[0][1], z = 5.0)
        end = carla.Location(x = real_trajectory[1][0], y = real_trajectory[1][1], z = 5.0)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="backend.carla_env.CARLA_ENV.apply_vehicle_control"><code class="name flex">
<span>def <span class="ident">apply_vehicle_control</span></span>(<span>self, uniquename, vehicle_control)</span>
</code></dt>
<dd>
<div class="desc"><p>Effects: apply control to a specific vehicle</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>str TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>vehicle_control</code></strong> :&ensp;<code>vehicle control TYPE, &lt;https://carla.readthedocs.io/en/latest/python_api/#carla.Vehicle&gt;</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_vehicle_control(self, uniquename, vehicle_control):
    &#39;&#39;&#39;
    Effects: apply control to a specific vehicle

    Parameters
    ----------
    uniquename : str TYPE
        DESCRIPTION.
    vehicle_control : vehicle control TYPE, https://carla.readthedocs.io/en/latest/python_api/#carla.Vehicle
        DESCRIPTION.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    vehicle = self.vehicle_dict[uniquename]
    vehicle.apply_control(vehicle_control)</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.check_vehicle_in_back_freeway"><code class="name flex">
<span>def <span class="ident">check_vehicle_in_back_freeway</span></span>(<span>self, uniquename, safety_distance)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the vehicle.</dd>
<dt><strong><code>safety_distance</code></strong> :&ensp;<code>float</code></dt>
<dd>allowed closest distance between two vehicles</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>has_vehicle_in_back</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether there exists a vehicle within safety distance</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>distance between this vehicle and the vehicle in the front</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_vehicle_in_back_freeway(self, uniquename, safety_distance):
    &#39;&#39;&#39;
    
    

    Parameters
    ----------
    uniquename : str
        name of the vehicle.
        
    safety_distance: float
        allowed closest distance between two vehicles

    Returns
    -------
    has_vehicle_in_back : bool
        whether there exists a vehicle within safety distance
    distance: float
        distance between this vehicle and the vehicle in the front

    &#39;&#39;&#39;
    # get the distance between this vehicle and other vehicles
    distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
    
    # get the bounding box of this vehicle
    vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
    safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
    
    has_vehicle_in_back = False
    distance = None
    smallest_distance = np.inf
    
    vehicle_1 = self.vehicle_dict[uniquename]
    location_1 = vehicle_1.get_transform().location
    forward_vector = vehicle_1.get_transform().get_forward_vector()
    
    for name in distance_with_other_vehicle:
        if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
            location_2 = self.vehicle_dict[name].get_transform().location
            vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
            forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
            
            norm_vec1_2 = vec1_2 / np.linalg.norm(vec1_2)
            norm_forward_vector_2d = forward_vector_2d / np.linalg.norm(forward_vector_2d)
            dot_product = np.dot(norm_vec1_2,norm_forward_vector_2d)
            angle = np.arccos(dot_product)
            
            
            
            if angle &gt; np.pi - np.arcsin((vehicle_bb.y  / 2) / distance_with_other_vehicle[name]):#np.arcsin((vehicle_bb.y  + 1) / distance_with_other_vehicle[name]):#np.arctan(vehicle_bb.y / vehicle_bb.x): 
                has_vehicle_in_back = True
                distance = np.dot(vec1_2,forward_vector_2d)
                if abs(distance) &lt; abs(smallest_distance):
                    smallest_distance = distance
        
    return has_vehicle_in_back, smallest_distance</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.check_vehicle_in_front"><code class="name flex">
<span>def <span class="ident">check_vehicle_in_front</span></span>(<span>self, uniquename, safety_distance)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the vehicle.</dd>
<dt><strong><code>safety_distance</code></strong> :&ensp;<code>float</code></dt>
<dd>allowed closest distance between two vehicles</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>has_vehicle_in_front</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether there exists a vehicle within safety distance</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>distance between this vehicle and the vehicle in the front</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_vehicle_in_front(self, uniquename, safety_distance):
    &#39;&#39;&#39;
    

    Parameters
    ----------
    uniquename : str
        name of the vehicle.
        
    safety_distance: float
        allowed closest distance between two vehicles

    Returns
    -------
    has_vehicle_in_front : bool
        whether there exists a vehicle within safety distance
    distance: float
        distance between this vehicle and the vehicle in the front

    &#39;&#39;&#39;
    # get the distance between this vehicle and other vehicles
    distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
    
    # get the bounding box of this vehicle
    vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
    safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
    
    has_vehicle_in_front = False
    distance = None
    
    vehicle_1 = self.vehicle_dict[uniquename]
    location_1 = vehicle_1.get_transform().location
    forward_vector = vehicle_1.get_transform().get_forward_vector()
    
    for name in distance_with_other_vehicle:
        if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
            location_2 = self.vehicle_dict[name].get_transform().location
            vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
            forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
            
            norm_vec1_2 = vec1_2 / np.linalg.norm(vec1_2)
            norm_forward_vector_2d = forward_vector_2d / np.linalg.norm(forward_vector_2d)
            dot_product = np.dot(norm_vec1_2,norm_forward_vector_2d)
            angle = np.arccos(dot_product)
            
            
            
            if angle &lt; np.arctan(vehicle_bb.y /  vehicle_bb.x):#np.arcsin((vehicle_bb.y  + 1) / distance_with_other_vehicle[name]):#np.arctan(vehicle_bb.y / vehicle_bb.x): 
                has_vehicle_in_front = True
                distance = np.dot(vec1_2,forward_vector_2d)
                break
        
    return has_vehicle_in_front, distance</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.check_vehicle_in_front_freeway"><code class="name flex">
<span>def <span class="ident">check_vehicle_in_front_freeway</span></span>(<span>self, uniquename, safety_distance)</span>
</code></dt>
<dd>
<div class="desc"><p>greatly narrow the front view for freeway</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the vehicle.</dd>
<dt><strong><code>safety_distance</code></strong> :&ensp;<code>float</code></dt>
<dd>allowed closest distance between two vehicles</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>has_vehicle_in_front</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether there exists a vehicle within safety distance</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>distance between this vehicle and the vehicle in the front</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_vehicle_in_front_freeway(self, uniquename, safety_distance):
    &#39;&#39;&#39;
    greatly narrow the front view for freeway
    

    Parameters
    ----------
    uniquename : str
        name of the vehicle.
        
    safety_distance: float
        allowed closest distance between two vehicles

    Returns
    -------
    has_vehicle_in_front : bool
        whether there exists a vehicle within safety distance
    distance: float
        distance between this vehicle and the vehicle in the front

    &#39;&#39;&#39;
    # get the distance between this vehicle and other vehicles
    distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
    
    # get the bounding box of this vehicle
    vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
    safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
    
    has_vehicle_in_front = False
    distance = None
    
    vehicle_1 = self.vehicle_dict[uniquename]
    location_1 = vehicle_1.get_transform().location
    forward_vector = vehicle_1.get_transform().get_forward_vector()
    
    for name in distance_with_other_vehicle:
        if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
            location_2 = self.vehicle_dict[name].get_transform().location
            vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
            forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
            
            norm_vec1_2 = vec1_2 / np.linalg.norm(vec1_2)
            norm_forward_vector_2d = forward_vector_2d / np.linalg.norm(forward_vector_2d)
            dot_product = np.dot(norm_vec1_2,norm_forward_vector_2d)
            angle = np.arccos(dot_product)
            
            
            
            if angle &lt; np.pi / 36:#np.arcsin((vehicle_bb.y  / 2) / distance_with_other_vehicle[name]):#np.arcsin((vehicle_bb.y  + 1) / distance_with_other_vehicle[name]):#np.arctan(vehicle_bb.y / vehicle_bb.x): 
                has_vehicle_in_front = True
                distance = np.dot(vec1_2,forward_vector_2d)
                break
        
    return has_vehicle_in_front, distance</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.check_vehicle_in_left"><code class="name flex">
<span>def <span class="ident">check_vehicle_in_left</span></span>(<span>self, uniquename, safety_distance=6)</span>
</code></dt>
<dd>
<div class="desc"><p>function checking whether a left vehicle is too close to the current vehicle
this function is primarily designed to help decide whether a vehicle can safely change lane</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the vehicle.</dd>
<dt><strong><code>safety_distance</code></strong> :&ensp;<code>float</code></dt>
<dd>allowed closest distance between two vehicles</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>has_vehicle_in_left</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether there exists a vehicle within safety distance</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>distance between this vehicle and the vehicle to the right</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_vehicle_in_left(self, uniquename, safety_distance = 6):
    &#39;&#39;&#39;
    function checking whether a left vehicle is too close to the current vehicle
    this function is primarily designed to help decide whether a vehicle can safely change lane

    Parameters
    ----------
    uniquename : str
        name of the vehicle.
        
    safety_distance: float
        allowed closest distance between two vehicles

    Returns
    -------
    has_vehicle_in_left : bool
        whether there exists a vehicle within safety distance
    distance: float
        distance between this vehicle and the vehicle to the right

    &#39;&#39;&#39;
    # get the distance between this vehicle and other vehicles
    distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
    
    # get the bounding box of this vehicle
    vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
    safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
    
    has_vehicle_in_left = False
    distance = None
    smallest_distance = np.inf
    
    vehicle_1 = self.vehicle_dict[uniquename]
    location_1 = vehicle_1.get_transform().location
    forward_vector = vehicle_1.get_transform().get_forward_vector()
    forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
    forward_vector_3d = np.array([forward_vector.x, forward_vector.y, 0])
    
    for name in distance_with_other_vehicle:
        if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
            print(distance_with_other_vehicle[name])    
        
            location_2 = self.vehicle_dict[name].get_transform().location
            vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y, 0])
            vec1_2_2d = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
            cross_product = np.cross(forward_vector_3d, vec1_2)
            if cross_product[2] &lt; 0: # this is the only difference between the check_vehicle_in_left / check_vehicle_in_right function 
                has_vehicle_in_left = True
                distance = np.dot(forward_vector_2d, vec1_2_2d)
                if abs(distance) &lt;= smallest_distance:
                    smallest_distance = distance
            
    return has_vehicle_in_left, smallest_distance</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.check_vehicle_in_right"><code class="name flex">
<span>def <span class="ident">check_vehicle_in_right</span></span>(<span>self, uniquename, safety_distance=6)</span>
</code></dt>
<dd>
<div class="desc"><p>function checking whether a right vehicle is too close to the current vehicle
this function is primarily designed to help decide whether a vehicle can safely change lane</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the vehicle.</dd>
<dt><strong><code>safety_distance</code></strong> :&ensp;<code>float</code></dt>
<dd>allowed closest distance between two vehicles</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>has_vehicle_in_right</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether there exists a vehicle within safety distance</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>distance between this vehicle and the vehicle to the right</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_vehicle_in_right(self, uniquename, safety_distance = 6):
    &#39;&#39;&#39;
    function checking whether a right vehicle is too close to the current vehicle
    this function is primarily designed to help decide whether a vehicle can safely change lane

    Parameters
    ----------
    uniquename : str
        name of the vehicle.
        
    safety_distance: float
        allowed closest distance between two vehicles

    Returns
    -------
    has_vehicle_in_right : bool
        whether there exists a vehicle within safety distance
    distance: float
        distance between this vehicle and the vehicle to the right

    &#39;&#39;&#39;
    # get the distance between this vehicle and other vehicles
    distance_with_other_vehicle = self.distance_between_vehicles[uniquename]
    
    # get the bounding box of this vehicle
    vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
    safety_distance += vehicle_bb.x / 2 # add the half length of the vehicle
    
    has_vehicle_in_right = False
    distance = None
    
    smallest_distance = np.inf
    
    vehicle_1 = self.vehicle_dict[uniquename]
    location_1 = vehicle_1.get_transform().location
    forward_vector = vehicle_1.get_transform().get_forward_vector()
    forward_vector_2d = np.array([forward_vector.x, forward_vector.y])
    forward_vector_3d = np.array([forward_vector.x, forward_vector.y, 0])
    
    for name in distance_with_other_vehicle:
        if name != uniquename and distance_with_other_vehicle[name] &lt; safety_distance and name in self.vehicle_dict: # a possible vehicle
            print(distance_with_other_vehicle[name])
        
            location_2 = self.vehicle_dict[name].get_transform().location
            vec1_2 = np.array([location_2.x - location_1.x, location_2.y - location_1.y, 0])
            vec1_2_2d = np.array([location_2.x - location_1.x, location_2.y - location_1.y])
            cross_product = np.cross(forward_vector_3d, vec1_2)
            if cross_product[2] &gt; 0: # left hand system
                has_vehicle_in_right = True
                distance = np.dot(forward_vector_2d, vec1_2_2d)
                if abs(distance) &lt;= smallest_distance:
                    smallest_distance = distance
                
            
    return has_vehicle_in_right, smallest_distance</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.config_env"><code class="name flex">
<span>def <span class="ident">config_env</span></span>(<span>self, synchrony=False, delta_seconds=0.02)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_env(self, synchrony = False, delta_seconds = 0.02):
    
    self.synchrony = synchrony
    self.delta_seconds = delta_seconds
    settings = self.world.get_settings()
    settings.synchronous_mode = synchrony
    settings.fixed_delta_seconds = delta_seconds
    self.world.apply_settings(settings)</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.destroy_actors"><code class="name flex">
<span>def <span class="ident">destroy_actors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="effects">Effects</h2>
<p>Destroy all actors that have been spawned</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy_actors(self):
    &#39;&#39;&#39;
    Effects
    -------
    Destroy all actors that have been spawned

    Returns
    -------
    None.

    &#39;&#39;&#39;
    for index in self.vehicle_dict.keys():
        self.vehicle_dict[index].destroy()
    for index in self.walker_dict.keys():
        self.walker_dict[index].destroy()
    for index in self.sensor_dict.keys():
        self.sensor_dict[index].destroy()
        
    self.vehicle_dict.clear()
    self.walker_dict.clear()
    self.sensor_dict.clear()
    print(&#34;destroyed all actors&#34;)</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.destroy_vehicle"><code class="name flex">
<span>def <span class="ident">destroy_vehicle</span></span>(<span>self, uniquename)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy_vehicle(self, uniquename):
    if uniquename in self.vehicle_dict:
        self.vehicle_dict[uniquename].destroy() # destroy the vehicle in carla
        self.vehicle_dict.pop(uniquename) # remove the vehicle from dictionary</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.draw_real_trajectory"><code class="name flex">
<span>def <span class="ident">draw_real_trajectory</span></span>(<span>self, real_trajectory)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw the real trajectory</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>real_trajectory</code></strong> :&ensp;<code>a deque</code> of <code>2 (x,y) tuple</code></dt>
<dd>stores the current and previous 2d location of the vehicle</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_real_trajectory(self, real_trajectory):
    &#39;&#39;&#39;
    Draw the real trajectory

    Parameters
    ----------
    real_trajectory : a deque of 2 (x,y) tuple
        stores the current and previous 2d location of the vehicle

    Returns
    -------
    None.

    &#39;&#39;&#39;
    begin = carla.Location(x = real_trajectory[0][0], y = real_trajectory[0][1], z = 5.0)
    end = carla.Location(x = real_trajectory[1][0], y = real_trajectory[1][1], z = 5.0)</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.draw_waypoints"><code class="name flex">
<span>def <span class="ident">draw_waypoints</span></span>(<span>self, trajectory, points)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw the way points and trajectory for the vehicle to follow</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code>numpy 2d array</code></dt>
<dd>the interpolated trajectory of a vehicle.</dd>
<dt><strong><code>points</code></strong> :&ensp;<code>list</code> of <code>(x,y)</code></dt>
<dd>waypoints to highlight</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_waypoints(self, trajectory, points):
    &#39;&#39;&#39;
    Draw the way points and trajectory for the vehicle to follow

    Parameters
    ----------
    trajectory : numpy 2d array
        the interpolated trajectory of a vehicle.
    points : list of (x,y)
        waypoints to highlight

    Returns
    -------
    None.

    &#39;&#39;&#39;
    for ii in range(len(points) - 1):
        location = carla.Location(x = points[ii][0], y = points[ii][1], z = 5.0)
        self.world.debug.draw_point(location, size = 0.1, color = orange, life_time=0.0, persistent_lines=True)
    
    location = carla.Location(x = points[-1][0], y = points[-1][1], z = 5.0)
    self.world.debug.draw_point(location, size = 0.1, color = red, life_time=0.0, persistent_lines=True)
    
    for ii in range(1,len(trajectory)):
        begin = carla.Location(x = trajectory[ii - 1][0], y = trajectory[ii - 1][1], z = 5.0)
        end = carla.Location(x = trajectory[ii][0], y = trajectory[ii][1], z = 5.0)
        self.world.debug.draw_line(begin, end, thickness=0.8, color=orange, life_time=0.0, persistent_lines=True)</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.get_forward_speed"><code class="name flex">
<span>def <span class="ident">get_forward_speed</span></span>(<span>self, uniquename)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the forward speed of the vehicle</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>name of the vehicle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>forward speed of the vehicle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_forward_speed(self, uniquename):
    &#39;&#39;&#39;
    Get the forward speed of the vehicle

    Parameters
    ----------
    uniquename : TYPE
        name of the vehicle.

    Returns
    -------
    forward speed of the vehicle.

    &#39;&#39;&#39;
    vehicle = self.vehicle_dict[uniquename]
    velocity = vehicle.get_velocity()
    return (velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2)**0.5</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.get_traffic_light_state"><code class="name flex">
<span>def <span class="ident">get_traffic_light_state</span></span>(<span>self, uniquename)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the vehicle..</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>The traffic light state corresponding to this vehicle.</dt>
<dt><code>If no traffic light available, return None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_traffic_light_state(self, uniquename):
    &#39;&#39;&#39;
    

    Parameters
    ----------
    uniquename : str
        name of the vehicle..

    Returns
    -------
    The traffic light state corresponding to this vehicle.
    If no traffic light available, return None

    &#39;&#39;&#39;
    vehicle = self.vehicle_dict[uniquename]
    state = None
    if vehicle.is_at_traffic_light():
        light = vehicle.get_traffic_light()
        state = light.get_state()
        
    return state</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.get_transform_2d"><code class="name flex">
<span>def <span class="ident">get_transform_2d</span></span>(<span>self, uniquename)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the vehicle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>location and orientation of the vehicle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transform_2d(self, uniquename):
    &#39;&#39;&#39;
    

    Parameters
    ----------
    uniquename : str
        name of the vehicle.

    Returns
    -------
    location and orientation of the vehicle.

    &#39;&#39;&#39;
    vehicle = self.vehicle_dict[uniquename]
    transform = vehicle.get_transform()
    location_2d = [transform.location.x, transform.location.y]
    yaw = transform.rotation.yaw
    
    return (location_2d,yaw)</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.get_transform_3d"><code class="name flex">
<span>def <span class="ident">get_transform_3d</span></span>(<span>self, uniquename)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the vehicle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>3d transform</code> of <code>the vehicle</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transform_3d(self, uniquename):
    &#39;&#39;&#39;
    

    Parameters
    ----------
    uniquename : str
        name of the vehicle.

    Returns
    -------
    3d transform of the vehicle

    &#39;&#39;&#39;
    vehicle = self.vehicle_dict[uniquename]
    transform = vehicle.get_transform()
    
    
    return transform</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.get_vehicle_bounding_box"><code class="name flex">
<span>def <span class="ident">get_vehicle_bounding_box</span></span>(<span>self, uniquename)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>string</code></dt>
<dd>uniquename of a vehicle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>the carla actor corresponding to the uniquename.</dt>
<dt><code>None type will be sent is uniquename doesn't exist</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vehicle_bounding_box(self, uniquename):
    &#39;&#39;&#39;
    

    Parameters
    ----------
    uniquename : string
        uniquename of a vehicle.

    Returns
    -------
    the carla actor corresponding to the uniquename.
    None type will be sent is uniquename doesn&#39;t exist
    

    &#39;&#39;&#39;
    ret_vehicle_bb = None
    if uniquename in self.vehicle_dict:
        ret_vehicle_bb = self.vehicle_dict[uniquename].bounding_box.extent
        
        
    return ret_vehicle_bb</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.get_vehicle_model_length"><code class="name flex">
<span>def <span class="ident">get_vehicle_model_length</span></span>(<span>self, model_name)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_name</code></strong> :&ensp;<code>string</code></dt>
<dd>the model name of a vehicle model, or type_id of a vehicle</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>the length</code> of <code>the vehicle,</code> or <code>bounding_box.extent.x</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vehicle_model_length(self, model_name):
    &#39;&#39;&#39;
    

    Parameters
    ----------
    model_name : string
        the model name of a vehicle model, or type_id of a vehicle

    Returns
    -------
    the length of the vehicle, or bounding_box.extent.x

    &#39;&#39;&#39;
    length = None
    if model_name in self.vehicle_model_length_config:
        length = float(self.vehicle_model_length_config[model_name])
    else:
        print(model_name)
        print(&#34;Error: invalid model_name entered to get vehicle model length&#34;)
    
    return length</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.move_vehicle_location"><code class="name flex">
<span>def <span class="ident">move_vehicle_location</span></span>(<span>self, uniquename, spawn_point)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>string</code></dt>
<dd>uniquename of a vehicle.</dd>
<dt><strong><code>spawn_point</code></strong> :&ensp;<code> carla.Transform()</code></dt>
<dd>new spawn point of the vehicle</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_vehicle_location(self, uniquename, spawn_point):
    &#39;&#39;&#39;
    

    Parameters
    ----------
    uniquename : string
        uniquename of a vehicle.
    spawn_point :  carla.Transform()
        new spawn point of the vehicle

    Returns
    -------
    None.

    &#39;&#39;&#39;
    
    
    vehicle = self.vehicle_dict[uniquename]
    vehicle.set_transform(spawn_point)</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.set_vehicle_velocity"><code class="name flex">
<span>def <span class="ident">set_vehicle_velocity</span></span>(<span>self, uniquename, vehicle_velocity)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>string</code></dt>
<dd>uniquename of vehicle.</dd>
<dt><strong><code>vehicle_velocity</code></strong> :&ensp;<code>varla.Vector3D</code></dt>
<dd>vehicle speed</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_vehicle_velocity(self, uniquename, vehicle_velocity):
    &#39;&#39;&#39;
    

    Parameters
    ----------
    uniquename : string
        uniquename of vehicle.
    vehicle_velocity : varla.Vector3D
        vehicle speed

    Returns
    -------
    None.

    &#39;&#39;&#39;
    vehicle = self.vehicle_dict[uniquename]
    vehicle.set_target_velocity(vehicle_velocity)</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.spawn_vehicle"><code class="name flex">
<span>def <span class="ident">spawn_vehicle</span></span>(<span>self, model_name=None, spawn_point=None, color=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_name</code></strong> :&ensp;<code>str TYPE</code>, optional</dt>
<dd>DESCRIPTION:
The default is None.</dd>
<dt><strong><code>spawn_point</code></strong> :&ensp;<code>carla.Transform() TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is None.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the color of the vehicle</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Uniquename of the actor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spawn_vehicle(self, model_name = None, spawn_point = None, color = None):
    &#39;&#39;&#39;
    Parameters
    ----------
    model_name : str TYPE, optional
        DESCRIPTION:  The default is None.
    spawn_point : carla.Transform() TYPE, optional
        DESCRIPTION. The default is None.
    color : str, optional
        the color of the vehicle

    Returns
    -------
    Uniquename of the actor.

    &#39;&#39;&#39;
    if model_name == None:
        bp = random.choice(self.blueprint_library.filter(&#39;vehicle.*.*&#39;))
    else:
        bp = random.choice(self.blueprint_library.filter(model_name))
    
    if spawn_point == None:
        spawn_point = random.choice(self.world.get_map().get_spawn_points())
    
    if color != None and bp.has_attribute(&#39;color&#39;):
        bp.set_attribute(&#39;color&#39;,color)
    
    
    vehicle = self.world.spawn_actor(bp,spawn_point)
    self.vehicle_dict[vehicle.type_id + &#39;_&#39; + str(vehicle.id)] = vehicle
    return vehicle.type_id + &#39;_&#39; + str(vehicle.id)</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.update_vehicle_distance"><code class="name flex">
<span>def <span class="ident">update_vehicle_distance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the distance between each 2 vehicles
This function should be called each world.tick()</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_vehicle_distance(self):
    &#39;&#39;&#39;
    Update the distance between each 2 vehicles
    This function should be called each world.tick()

    Returns
    -------
    None.

    &#39;&#39;&#39;
    self.distance_between_vehicles.reset() # reset the configuration file each update
    
    # get all available vehicles
    vehicle_uniquenames = []
    for name in self.vehicle_dict:
        vehicle_uniquenames.append(name)
        self.distance_between_vehicles[name] = {} # create empty storage
        
    for ii in range(len(vehicle_uniquenames)):
        for jj in range(ii,len(vehicle_uniquenames)):
            name_1 = vehicle_uniquenames[ii]
            name_2 = vehicle_uniquenames[jj]
            if name_1 == name_2:
                self.distance_between_vehicles[name_1][name_2] = 0.0 # distance with itself, 0.0
            else:
                vehicle_1 = self.vehicle_dict[name_1]
                vehicle_2 = self.vehicle_dict[name_2]
                location_1 = vehicle_1.get_transform().location
                location_2 = vehicle_2.get_transform().location
                distance = math.sqrt((location_1.x - location_2.x)**2 + (location_1.y - location_2.y)**2)
                self.distance_between_vehicles[name_1][name_2] = distance
                self.distance_between_vehicles[name_2][name_1] = distance</code></pre>
</details>
</dd>
<dt id="backend.carla_env.CARLA_ENV.vehicle_available"><code class="name flex">
<span>def <span class="ident">vehicle_available</span></span>(<span>self, uniquename)</span>
</code></dt>
<dd>
<div class="desc"><p>check whether the vehicle exists</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uniquename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the vehicle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>exists</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether the vehicle exists</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vehicle_available(self, uniquename):
    &#39;&#39;&#39;
    check whether the vehicle exists

    Parameters
    ----------
    uniquename : str
        name of the vehicle.

    Returns
    -------
    exists : bool
        whether the vehicle exists

    &#39;&#39;&#39;
    if uniquename in self.vehicle_dict:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backend" href="index.html">backend</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="backend.carla_env.config_world" href="#backend.carla_env.config_world">config_world</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backend.carla_env.CARLA_ENV" href="#backend.carla_env.CARLA_ENV">CARLA_ENV</a></code></h4>
<ul class="">
<li><code><a title="backend.carla_env.CARLA_ENV.apply_vehicle_control" href="#backend.carla_env.CARLA_ENV.apply_vehicle_control">apply_vehicle_control</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.check_vehicle_in_back_freeway" href="#backend.carla_env.CARLA_ENV.check_vehicle_in_back_freeway">check_vehicle_in_back_freeway</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.check_vehicle_in_front" href="#backend.carla_env.CARLA_ENV.check_vehicle_in_front">check_vehicle_in_front</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.check_vehicle_in_front_freeway" href="#backend.carla_env.CARLA_ENV.check_vehicle_in_front_freeway">check_vehicle_in_front_freeway</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.check_vehicle_in_left" href="#backend.carla_env.CARLA_ENV.check_vehicle_in_left">check_vehicle_in_left</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.check_vehicle_in_right" href="#backend.carla_env.CARLA_ENV.check_vehicle_in_right">check_vehicle_in_right</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.config_env" href="#backend.carla_env.CARLA_ENV.config_env">config_env</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.destroy_actors" href="#backend.carla_env.CARLA_ENV.destroy_actors">destroy_actors</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.destroy_vehicle" href="#backend.carla_env.CARLA_ENV.destroy_vehicle">destroy_vehicle</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.draw_real_trajectory" href="#backend.carla_env.CARLA_ENV.draw_real_trajectory">draw_real_trajectory</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.draw_waypoints" href="#backend.carla_env.CARLA_ENV.draw_waypoints">draw_waypoints</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.get_forward_speed" href="#backend.carla_env.CARLA_ENV.get_forward_speed">get_forward_speed</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.get_traffic_light_state" href="#backend.carla_env.CARLA_ENV.get_traffic_light_state">get_traffic_light_state</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.get_transform_2d" href="#backend.carla_env.CARLA_ENV.get_transform_2d">get_transform_2d</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.get_transform_3d" href="#backend.carla_env.CARLA_ENV.get_transform_3d">get_transform_3d</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.get_vehicle_bounding_box" href="#backend.carla_env.CARLA_ENV.get_vehicle_bounding_box">get_vehicle_bounding_box</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.get_vehicle_model_length" href="#backend.carla_env.CARLA_ENV.get_vehicle_model_length">get_vehicle_model_length</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.move_vehicle_location" href="#backend.carla_env.CARLA_ENV.move_vehicle_location">move_vehicle_location</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.set_vehicle_velocity" href="#backend.carla_env.CARLA_ENV.set_vehicle_velocity">set_vehicle_velocity</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.spawn_vehicle" href="#backend.carla_env.CARLA_ENV.spawn_vehicle">spawn_vehicle</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.update_vehicle_distance" href="#backend.carla_env.CARLA_ENV.update_vehicle_distance">update_vehicle_distance</a></code></li>
<li><code><a title="backend.carla_env.CARLA_ENV.vehicle_available" href="#backend.carla_env.CARLA_ENV.vehicle_available">vehicle_available</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>