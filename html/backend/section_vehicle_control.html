<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>backend.section_vehicle_control API documentation</title>
<meta name="description" content="Created on Thu Jul 23 10:15:47 2020 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backend.section_vehicle_control</code></h1>
</header>
<section id="section-intro">
<p>Created on Thu Jul 23 10:15:47 2020</p>
<p>@author: shijiliu</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Thu Jul 23 10:15:47 2020

@author: shijiliu
&#34;&#34;&#34;

import sys
sys.path.append(&#34;..&#34;)

import carla
import matplotlib.pyplot as plt
import numpy as np
from collections import deque
import time
import math

import control # the python-control package, install first

from backend.intersection_definition import Intersection, get_traffic_lights
from backend.carla_env import CARLA_ENV # self-written class that provides help functions, should be in the same folder
from configobj import ConfigObj
from backend.multiple_vehicle_control import VehicleControl

import copy


# color for debug use
red = carla.Color(255, 0, 0)
green = carla.Color(0, 255, 0)
blue = carla.Color(47, 210, 231)
cyan = carla.Color(0, 255, 255)
yellow = carla.Color(255, 255, 0)
orange = carla.Color(255, 162, 0)
white = carla.Color(255, 255, 255)


class VehicleControlFreeway(VehicleControl):
    def __init__(self, env, vehicle_config, delta_seconds, allow_collision = True):
        super().__init__(env, vehicle_config, delta_seconds, allow_collision = True)
        
    def _obey_safety_distance(self, current_ref_speed):
        # override the _obey_safety_distance method
        has_vehicle_in_front, distance = self.env.check_vehicle_in_front_freeway(self.model_uniquename, self.safety_distance) #self.env.check_vehicle_in_front_freeway(self.model_uniquename, self.safety_distance)
        
        if has_vehicle_in_front and abs(distance) &lt; self.L / 2 + 1.0 and not self.allow_collision:
            # if vehicle is about to collide with other vehicle and collision is not allowed
            # set the vehicle velocity to 0
            abrupt_stop_vel = carla.Vector3D(x = 0,y = 0,z = 0)
            self.env.set_vehicle_velocity(self.model_uniquename, abrupt_stop_vel) # set the velocity of vehicle
        
        
        if has_vehicle_in_front: 
            #print(&#34;---&#34;)
            #print(&#34;safety_distance: &#34;, self.safety_distance)
            #print(&#34;distance with previous vehicle &#34;, distance)
            return 0.0
        
        return current_ref_speed
    




class FullPathVehicleControl(VehicleControlFreeway):
    def __init__(self, env, vehicle_config, delta_seconds, allow_collision = True):
        super().__init__(env,vehicle_config,delta_seconds, allow_collision = True)
        
        # store the subject trajectory and left trajectory
        self.subject_trajectory = copy.copy(self.vehicle_config[&#34;subject_trajectory&#34;])
        self.subject_ref_speed = copy.copy(self.vehicle_config[&#34;subject_ref_speed_list&#34;])
        self.subject_max_ref_speed = copy.copy(self.vehicle_config[&#34;subject_max_speed_list&#34;])
        self.subject_min_ref_speed = copy.copy(self.vehicle_config[&#34;subject_min_speed_list&#34;])
        
        self.left_trajectory = copy.copy(self.vehicle_config[&#34;left_trajectory&#34;])
        self.left_ref_speed = copy.copy(self.vehicle_config[&#34;left_ref_speed_list&#34;])
        self.left_max_ref_speed = copy.copy(self.vehicle_config[&#34;left_max_speed_list&#34;])
        self.left_min_ref_speed = copy.copy(self.vehicle_config[&#34;left_min_speed_list&#34;])
        
        # store the current lane of the vehicle
        self.current_lane = copy.copy(self.vehicle_config[&#34;current_lane&#34;])
        
        # store the local time of the section the vehicle is in
        self.local_time = 0.0
        
        # store the time the vehicle is going to take command, (command should be &#34;lane&#34;)
        self.command_start_time = self.vehicle_config[&#34;command_start_time&#34;]
        
        # store time steps after executing the change lane command
        self.lane_change_step = 0
        
        # store variable for deciding whether the vehicle should change lane
        self.lane_change_available = False
        
    def _change_lane(self):
        &#39;&#39;&#39;
        order the vehicle to change its lane

        Returns
        -------
        None.

        &#39;&#39;&#39;
        # check whether the vehicle is safe to change lane
        if not self.lane_change_available:
            if self.current_lane == &#34;subject&#34;:
                has_vehicle_in_left, distance = self.env.check_vehicle_in_left(self.model_uniquename, safety_distance = 20)
                
                print(&#34;--------&#34;)
                print(&#34;has_vehicle_in_left : &#34;, has_vehicle_in_left)
                print(&#34;distance: &#34;, distance)
                if has_vehicle_in_left:
                    if distance &lt; 0:
                        self.ref_speed_list = copy.copy(self.subject_max_ref_speed) # accelerate to max speed if the close vehicle is behind
                                                                                    # the current vehicle
                    else:
                        self.ref_speed_list = copy.copy(self.subject_min_ref_speed) # deccelerate to min speed if the close vehicle is in
                                                                                    # front of the current vehicle
                    return # only change speed, don&#39;t change lane
                else:
                    self.lane_change_available = True # no close vehicle in left lane, enable lane change
            else:
                # vehicle currently in right lane
                has_vehicle_in_right, distance = self.env.check_vehicle_in_right(self.model_uniquename, safety_distance = 20)
                
                print(&#34;--------&#34;)
                print(&#34;has_vehicle_in_right : &#34;, has_vehicle_in_right)
                print(&#34;distance: &#34;, distance)
                
                if has_vehicle_in_right:
                    if distance &lt; 0:
                        self.ref_speed_list = copy.copy(self.left_max_ref_speed) # accelerate to max speed if the close vehicle is behind
                                                                                    # the current vehicle
                    else:
                        self.ref_speed_list = copy.copy(self.left_min_ref_speed) # deccelerate to min speed if the close vehicle is in
                                                                                 # front of the current vehicle
                    return # only change speed, don&#39;t change lane                                                   
                else:
                    self.lane_change_available = True # no close vehicle in left lane, enable lane change
        
        
        
        if self.lane_change_step == 0:
            if self.current_lane == &#34;subject&#34;:
                self.trajectory = copy.copy(self.left_trajectory)
                self.ref_speed_list = copy.copy(self.left_ref_speed)
                self.current_lane = &#34;left&#34;
            else:
                self.trajectory = copy.copy(self.subject_trajectory)
                self.ref_speed_list = copy.copy(self.subject_ref_speed)
                self.current_lane = &#34;subject&#34;
            self.lane_change_step += 1
            self.Lfc = 15.0 # set a large look ahead distance when changing the lane
        elif self.lane_change_step &gt; 0 and self.lane_change_step &lt; 15:
            self.lane_change_step += 1
        else:
            self.command = &#34;speed&#34; # have changed the lane, change the mode to speed
            self.lane_change_step = 0
            self.Lfc = 4.0 # change the look ahead distance back to its original value
            self.lane_change_available = False
        
    def update_local_time(self, local_time):
        # update the local time of the section the vehicle is in
        # the time is used to decide whether the vehicle is going to 
        # change direction
        self.local_time = local_time
        if self.command == &#34;lane&#34; and self.command_start_time &lt;= self.local_time:
            self._change_lane()

        elif self.command == &#34;distance&#34; and self.command_start_time &lt;= self.local_time:
            self._keep_distance()
            
        else:
            self._keep_speed()
            
    def _keep_speed(self):
        if self.current_lane == &#34;subject&#34;:
            self.ref_speed_list = copy.copy(self.subject_ref_speed) # accelerate to the max speed
        elif self.current_lane == &#34;left&#34;:
            self.ref_speed_list = copy.copy(self.left_ref_speed) # accelerate to the max speed
    
    def _keep_distance(self):
        pass

class LeadFollowVehicleControl(FullPathVehicleControl):
    def __init__(self, env, vehicle_config, delta_seconds, allow_collision = True):
        super().__init__(env, vehicle_config, delta_seconds, allow_collision = True)
        
        # store the vehicle type
        self.vehicle_type = self.vehicle_config[&#34;vehicle_type&#34;]
    
        
        # store the constant distance
        self.lead_follow_distance = self.vehicle_config[&#34;lead_follow_distance&#34;]
        if self.vehicle_type == &#34;lead&#34;:
            self.lead_follow_distance = - self.lead_follow_distance # if the vehicle is of &#34;lead&#34; type, the lead distance is negative
        self.lead_follow_far_limit = 1.05 * self.lead_follow_distance
        self.lead_follow_close_limit = 0.95 * self.lead_follow_distance
    
    
        # store variable indicating whether the current vehicle and the ego vehicle are within desired range
        self.within_desired_range = False
    
    def update_distance_with_ego(self, ego_transform):
        ego_location = ego_transform.location
        
        # get local location
        local_transform = self.env.get_transform_3d(self.model_uniquename)
        local_location = local_transform.location
        forward_vector = local_transform.get_forward_vector()
        forward_vector_2d = np.array([forward_vector.x,forward_vector.y])
        unit_forward_vector_2d =  forward_vector_2d / np.linalg.norm(forward_vector_2d)
        
        vec_loc_target = np.array([ego_location.x - local_location.x,ego_location.y - local_location.y])
        distance = np.dot(vec_loc_target,unit_forward_vector_2d)
        
        self.distance_with_ego = distance
    
    def _keep_distance(self):
        # keep constant distance between the current vehicle and the ego vehicle
        if self.vehicle_type == &#34;lead&#34;:
            # for lead vehicle, check if there exists vehicle in the back
            has_vehicle_in_back, distance = self.env.check_vehicle_in_back_freeway(self.model_uniquename,abs(self.lead_follow_distance) * 4 + self.safety_distance * 4) # use a large distance
            #print(&#34;---lead---&#34;)
            #print(&#34;distance with back vehicle &#34;, distance)
            if has_vehicle_in_back:
                if abs(self.distance_with_ego) &gt; abs(distance) + 1.0: # there exists at least one vehicle between current vehicle and lead vehicle
                    self.command = &#34;speed&#34;                            # give up keeping constant distance, keep constant speed
                    print(&#34;give up distance mode&#34;)
                    if self.current_lane == &#34;subject&#34;:
                        self.ref_speed_list = copy.copy(self.subject_ref_speed) # keep constant speed
                    elif self.current_lane == &#34;left&#34;:
                        self.ref_speed_list = copy.copy(self.left_ref_speed) # keep constant speed
                     
                    # set the vehicle speed
                    local_transform = self.env.get_transform_3d(self.model_uniquename)
                    forward_vector = local_transform.get_forward_vector()
                    vehicle_velocity = carla.Vector3D(x = forward_vector.x * self.subject_ref_speed[0], y = forward_vector.y * self.subject_ref_speed[0], z = forward_vector.z * self.subject_ref_speed[0])
                    self.env.set_vehicle_velocity(self.model_uniquename , vehicle_velocity) # set the velocity
                    return
            
            if self.distance_with_ego &lt;= self.lead_follow_far_limit: # the vehicle is leading the ego vehicle and far away
                # deccelerate
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_min_ref_speed) # decelerate to the min speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_min_ref_speed) # decelerate to the min speed
                    
                self.within_desired_range = False
            
            elif self.distance_with_ego &gt; self.lead_follow_close_limit and self.distance_with_ego &lt; 0: # the vehicle is leading 
                                                                                                       # and close to ego
                # accelerate
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_max_ref_speed) # accelerate to the max speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_max_ref_speed) # accelerate to the max speed
            
                self.within_desired_range = False
            
            else:
                # vehicle within expected range or lead vehicle behind the ego vehicle, which could happen due to change lane
                # keep normal navigation speed
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_ref_speed) # keep constant speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_ref_speed) # keep constant speed
            
                if self.within_desired_range == False: # just come into the desired range, set the speed
                    local_transform = self.env.get_transform_3d(self.model_uniquename)
                    forward_vector = local_transform.get_forward_vector()
                    vehicle_velocity = carla.Vector3D(x = forward_vector.x * self.subject_ref_speed[0], y = forward_vector.y * self.subject_ref_speed[0], z = forward_vector.z * self.subject_ref_speed[0])
                    self.env.set_vehicle_velocity(self.model_uniquename , vehicle_velocity) # set the velocity
                
                self.within_desired_range = True
            
            

            
        else: # &#34;follow&#34; vehicle
           # for follow vehicle, check if there exists vehicle in the front
            has_vehicle_in_front, distance = self.env.check_vehicle_in_front_freeway(self.model_uniquename, abs(self.lead_follow_distance))
            if has_vehicle_in_front: # has vehicle in front that is not the ego vehicle
                if abs(self.distance_with_ego) &gt; abs(distance) + 1.0: # there exists at least one vehicle between current vehicle and lead vehicle
                    self.command = &#34;speed&#34;                            # give up keeping constant distance, keep constant speed
                    
                    if self.current_lane == &#34;subject&#34;:
                        self.ref_speed_list = copy.copy(self.subject_ref_speed) # keep constant speed
                    elif self.current_lane == &#34;left&#34;:
                        self.ref_speed_list = copy.copy(self.left_ref_speed) # keep constant speed
                    return
        
            if self.distance_with_ego &gt;= self.lead_follow_far_limit: # the vehicle is following the ego vehicle and far away
                # accelerate
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_max_ref_speed) # accelerate to the max speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_max_ref_speed) # accelerate to the max speed
                self.within_desired_range = False
            
            elif self.distance_with_ego &lt; self.lead_follow_close_limit and self.distance_with_ego &gt; 0: # the vehicle is following 
                                                                                                       # and close to ego
                # deccelerate
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_min_ref_speed) # decelerate to the min speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_min_ref_speed) # decelerate to the min speed
                self.within_desired_range = False
            
            else:
                # vehicle within expected range or follow vehicle before the ego vehicle, which could happen due to change lane
                # keep normal navigation speed
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_ref_speed) # keep constant speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_ref_speed) # keep constant speed
    
                if self.within_desired_range == False: # just come into the desired range, set the speed
                    local_transform = self.env.get_transform_3d(self.model_uniquename)
                    forward_vector = local_transform.get_forward_vector()
                    vehicle_velocity = carla.Vector3D(x = forward_vector.x * self.subject_ref_speed[0], y = forward_vector.y * self.subject_ref_speed[0], z = forward_vector.z * self.subject_ref_speed[0])
                    self.env.set_vehicle_velocity(self.model_uniquename , vehicle_velocity) # set the velocity
                
                self.within_desired_range = True
            
    
    
        #print(&#34;distance with ego == &#34;, self.distance_with_ego)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backend.section_vehicle_control.FullPathVehicleControl"><code class="flex name class">
<span>class <span class="ident">FullPathVehicleControl</span></span>
<span>(</span><span>env, vehicle_config, delta_seconds, allow_collision=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>env</code></strong> :&ensp;<code>CARLA_ENV</code></dt>
<dd>the self-written environment for simulation</dd>
<dt><strong><code>vehicle_config</code></strong> :&ensp;<code>ConfigObj</code></dt>
<dd>the configuration file for this vehicle. The file is created inside the Intersection's add_vehicle function.
containing the trajectory and speed reference for the vehicle. The configuration file should also indicate whether
this vehicle should go or not.</dd>
<dt><strong><code>delta_seconds</code></strong> :&ensp;<code>float</code></dt>
<dd>time between two adjacent simulation step. Used for creating discrete controller</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FullPathVehicleControl(VehicleControlFreeway):
    def __init__(self, env, vehicle_config, delta_seconds, allow_collision = True):
        super().__init__(env,vehicle_config,delta_seconds, allow_collision = True)
        
        # store the subject trajectory and left trajectory
        self.subject_trajectory = copy.copy(self.vehicle_config[&#34;subject_trajectory&#34;])
        self.subject_ref_speed = copy.copy(self.vehicle_config[&#34;subject_ref_speed_list&#34;])
        self.subject_max_ref_speed = copy.copy(self.vehicle_config[&#34;subject_max_speed_list&#34;])
        self.subject_min_ref_speed = copy.copy(self.vehicle_config[&#34;subject_min_speed_list&#34;])
        
        self.left_trajectory = copy.copy(self.vehicle_config[&#34;left_trajectory&#34;])
        self.left_ref_speed = copy.copy(self.vehicle_config[&#34;left_ref_speed_list&#34;])
        self.left_max_ref_speed = copy.copy(self.vehicle_config[&#34;left_max_speed_list&#34;])
        self.left_min_ref_speed = copy.copy(self.vehicle_config[&#34;left_min_speed_list&#34;])
        
        # store the current lane of the vehicle
        self.current_lane = copy.copy(self.vehicle_config[&#34;current_lane&#34;])
        
        # store the local time of the section the vehicle is in
        self.local_time = 0.0
        
        # store the time the vehicle is going to take command, (command should be &#34;lane&#34;)
        self.command_start_time = self.vehicle_config[&#34;command_start_time&#34;]
        
        # store time steps after executing the change lane command
        self.lane_change_step = 0
        
        # store variable for deciding whether the vehicle should change lane
        self.lane_change_available = False
        
    def _change_lane(self):
        &#39;&#39;&#39;
        order the vehicle to change its lane

        Returns
        -------
        None.

        &#39;&#39;&#39;
        # check whether the vehicle is safe to change lane
        if not self.lane_change_available:
            if self.current_lane == &#34;subject&#34;:
                has_vehicle_in_left, distance = self.env.check_vehicle_in_left(self.model_uniquename, safety_distance = 20)
                
                print(&#34;--------&#34;)
                print(&#34;has_vehicle_in_left : &#34;, has_vehicle_in_left)
                print(&#34;distance: &#34;, distance)
                if has_vehicle_in_left:
                    if distance &lt; 0:
                        self.ref_speed_list = copy.copy(self.subject_max_ref_speed) # accelerate to max speed if the close vehicle is behind
                                                                                    # the current vehicle
                    else:
                        self.ref_speed_list = copy.copy(self.subject_min_ref_speed) # deccelerate to min speed if the close vehicle is in
                                                                                    # front of the current vehicle
                    return # only change speed, don&#39;t change lane
                else:
                    self.lane_change_available = True # no close vehicle in left lane, enable lane change
            else:
                # vehicle currently in right lane
                has_vehicle_in_right, distance = self.env.check_vehicle_in_right(self.model_uniquename, safety_distance = 20)
                
                print(&#34;--------&#34;)
                print(&#34;has_vehicle_in_right : &#34;, has_vehicle_in_right)
                print(&#34;distance: &#34;, distance)
                
                if has_vehicle_in_right:
                    if distance &lt; 0:
                        self.ref_speed_list = copy.copy(self.left_max_ref_speed) # accelerate to max speed if the close vehicle is behind
                                                                                    # the current vehicle
                    else:
                        self.ref_speed_list = copy.copy(self.left_min_ref_speed) # deccelerate to min speed if the close vehicle is in
                                                                                 # front of the current vehicle
                    return # only change speed, don&#39;t change lane                                                   
                else:
                    self.lane_change_available = True # no close vehicle in left lane, enable lane change
        
        
        
        if self.lane_change_step == 0:
            if self.current_lane == &#34;subject&#34;:
                self.trajectory = copy.copy(self.left_trajectory)
                self.ref_speed_list = copy.copy(self.left_ref_speed)
                self.current_lane = &#34;left&#34;
            else:
                self.trajectory = copy.copy(self.subject_trajectory)
                self.ref_speed_list = copy.copy(self.subject_ref_speed)
                self.current_lane = &#34;subject&#34;
            self.lane_change_step += 1
            self.Lfc = 15.0 # set a large look ahead distance when changing the lane
        elif self.lane_change_step &gt; 0 and self.lane_change_step &lt; 15:
            self.lane_change_step += 1
        else:
            self.command = &#34;speed&#34; # have changed the lane, change the mode to speed
            self.lane_change_step = 0
            self.Lfc = 4.0 # change the look ahead distance back to its original value
            self.lane_change_available = False
        
    def update_local_time(self, local_time):
        # update the local time of the section the vehicle is in
        # the time is used to decide whether the vehicle is going to 
        # change direction
        self.local_time = local_time
        if self.command == &#34;lane&#34; and self.command_start_time &lt;= self.local_time:
            self._change_lane()

        elif self.command == &#34;distance&#34; and self.command_start_time &lt;= self.local_time:
            self._keep_distance()
            
        else:
            self._keep_speed()
            
    def _keep_speed(self):
        if self.current_lane == &#34;subject&#34;:
            self.ref_speed_list = copy.copy(self.subject_ref_speed) # accelerate to the max speed
        elif self.current_lane == &#34;left&#34;:
            self.ref_speed_list = copy.copy(self.left_ref_speed) # accelerate to the max speed
    
    def _keep_distance(self):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backend.section_vehicle_control.VehicleControlFreeway" href="#backend.section_vehicle_control.VehicleControlFreeway">VehicleControlFreeway</a></li>
<li><a title="backend.multiple_vehicle_control.VehicleControl" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl">VehicleControl</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backend.section_vehicle_control.LeadFollowVehicleControl" href="#backend.section_vehicle_control.LeadFollowVehicleControl">LeadFollowVehicleControl</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="backend.section_vehicle_control.FullPathVehicleControl.update_local_time"><code class="name flex">
<span>def <span class="ident">update_local_time</span></span>(<span>self, local_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_local_time(self, local_time):
    # update the local time of the section the vehicle is in
    # the time is used to decide whether the vehicle is going to 
    # change direction
    self.local_time = local_time
    if self.command == &#34;lane&#34; and self.command_start_time &lt;= self.local_time:
        self._change_lane()

    elif self.command == &#34;distance&#34; and self.command_start_time &lt;= self.local_time:
        self._keep_distance()
        
    else:
        self._keep_speed()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backend.section_vehicle_control.VehicleControlFreeway" href="#backend.section_vehicle_control.VehicleControlFreeway">VehicleControlFreeway</a></b></code>:
<ul class="hlist">
<li><code><a title="backend.section_vehicle_control.VehicleControlFreeway.fake_pure_pursuit_control_wrapper" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.fake_pure_pursuit_control_wrapper">fake_pure_pursuit_control_wrapper</a></code></li>
<li><code><a title="backend.section_vehicle_control.VehicleControlFreeway.get_target_index" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.get_target_index">get_target_index</a></code></li>
<li><code><a title="backend.section_vehicle_control.VehicleControlFreeway.pure_pursuit_control" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.pure_pursuit_control">pure_pursuit_control</a></code></li>
<li><code><a title="backend.section_vehicle_control.VehicleControlFreeway.pure_pursuit_control_wrapper" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.pure_pursuit_control_wrapper">pure_pursuit_control_wrapper</a></code></li>
<li><code><a title="backend.section_vehicle_control.VehicleControlFreeway.speed_control" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.speed_control">speed_control</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backend.section_vehicle_control.LeadFollowVehicleControl"><code class="flex name class">
<span>class <span class="ident">LeadFollowVehicleControl</span></span>
<span>(</span><span>env, vehicle_config, delta_seconds, allow_collision=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>env</code></strong> :&ensp;<code>CARLA_ENV</code></dt>
<dd>the self-written environment for simulation</dd>
<dt><strong><code>vehicle_config</code></strong> :&ensp;<code>ConfigObj</code></dt>
<dd>the configuration file for this vehicle. The file is created inside the Intersection's add_vehicle function.
containing the trajectory and speed reference for the vehicle. The configuration file should also indicate whether
this vehicle should go or not.</dd>
<dt><strong><code>delta_seconds</code></strong> :&ensp;<code>float</code></dt>
<dd>time between two adjacent simulation step. Used for creating discrete controller</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LeadFollowVehicleControl(FullPathVehicleControl):
    def __init__(self, env, vehicle_config, delta_seconds, allow_collision = True):
        super().__init__(env, vehicle_config, delta_seconds, allow_collision = True)
        
        # store the vehicle type
        self.vehicle_type = self.vehicle_config[&#34;vehicle_type&#34;]
    
        
        # store the constant distance
        self.lead_follow_distance = self.vehicle_config[&#34;lead_follow_distance&#34;]
        if self.vehicle_type == &#34;lead&#34;:
            self.lead_follow_distance = - self.lead_follow_distance # if the vehicle is of &#34;lead&#34; type, the lead distance is negative
        self.lead_follow_far_limit = 1.05 * self.lead_follow_distance
        self.lead_follow_close_limit = 0.95 * self.lead_follow_distance
    
    
        # store variable indicating whether the current vehicle and the ego vehicle are within desired range
        self.within_desired_range = False
    
    def update_distance_with_ego(self, ego_transform):
        ego_location = ego_transform.location
        
        # get local location
        local_transform = self.env.get_transform_3d(self.model_uniquename)
        local_location = local_transform.location
        forward_vector = local_transform.get_forward_vector()
        forward_vector_2d = np.array([forward_vector.x,forward_vector.y])
        unit_forward_vector_2d =  forward_vector_2d / np.linalg.norm(forward_vector_2d)
        
        vec_loc_target = np.array([ego_location.x - local_location.x,ego_location.y - local_location.y])
        distance = np.dot(vec_loc_target,unit_forward_vector_2d)
        
        self.distance_with_ego = distance
    
    def _keep_distance(self):
        # keep constant distance between the current vehicle and the ego vehicle
        if self.vehicle_type == &#34;lead&#34;:
            # for lead vehicle, check if there exists vehicle in the back
            has_vehicle_in_back, distance = self.env.check_vehicle_in_back_freeway(self.model_uniquename,abs(self.lead_follow_distance) * 4 + self.safety_distance * 4) # use a large distance
            #print(&#34;---lead---&#34;)
            #print(&#34;distance with back vehicle &#34;, distance)
            if has_vehicle_in_back:
                if abs(self.distance_with_ego) &gt; abs(distance) + 1.0: # there exists at least one vehicle between current vehicle and lead vehicle
                    self.command = &#34;speed&#34;                            # give up keeping constant distance, keep constant speed
                    print(&#34;give up distance mode&#34;)
                    if self.current_lane == &#34;subject&#34;:
                        self.ref_speed_list = copy.copy(self.subject_ref_speed) # keep constant speed
                    elif self.current_lane == &#34;left&#34;:
                        self.ref_speed_list = copy.copy(self.left_ref_speed) # keep constant speed
                     
                    # set the vehicle speed
                    local_transform = self.env.get_transform_3d(self.model_uniquename)
                    forward_vector = local_transform.get_forward_vector()
                    vehicle_velocity = carla.Vector3D(x = forward_vector.x * self.subject_ref_speed[0], y = forward_vector.y * self.subject_ref_speed[0], z = forward_vector.z * self.subject_ref_speed[0])
                    self.env.set_vehicle_velocity(self.model_uniquename , vehicle_velocity) # set the velocity
                    return
            
            if self.distance_with_ego &lt;= self.lead_follow_far_limit: # the vehicle is leading the ego vehicle and far away
                # deccelerate
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_min_ref_speed) # decelerate to the min speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_min_ref_speed) # decelerate to the min speed
                    
                self.within_desired_range = False
            
            elif self.distance_with_ego &gt; self.lead_follow_close_limit and self.distance_with_ego &lt; 0: # the vehicle is leading 
                                                                                                       # and close to ego
                # accelerate
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_max_ref_speed) # accelerate to the max speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_max_ref_speed) # accelerate to the max speed
            
                self.within_desired_range = False
            
            else:
                # vehicle within expected range or lead vehicle behind the ego vehicle, which could happen due to change lane
                # keep normal navigation speed
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_ref_speed) # keep constant speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_ref_speed) # keep constant speed
            
                if self.within_desired_range == False: # just come into the desired range, set the speed
                    local_transform = self.env.get_transform_3d(self.model_uniquename)
                    forward_vector = local_transform.get_forward_vector()
                    vehicle_velocity = carla.Vector3D(x = forward_vector.x * self.subject_ref_speed[0], y = forward_vector.y * self.subject_ref_speed[0], z = forward_vector.z * self.subject_ref_speed[0])
                    self.env.set_vehicle_velocity(self.model_uniquename , vehicle_velocity) # set the velocity
                
                self.within_desired_range = True
            
            

            
        else: # &#34;follow&#34; vehicle
           # for follow vehicle, check if there exists vehicle in the front
            has_vehicle_in_front, distance = self.env.check_vehicle_in_front_freeway(self.model_uniquename, abs(self.lead_follow_distance))
            if has_vehicle_in_front: # has vehicle in front that is not the ego vehicle
                if abs(self.distance_with_ego) &gt; abs(distance) + 1.0: # there exists at least one vehicle between current vehicle and lead vehicle
                    self.command = &#34;speed&#34;                            # give up keeping constant distance, keep constant speed
                    
                    if self.current_lane == &#34;subject&#34;:
                        self.ref_speed_list = copy.copy(self.subject_ref_speed) # keep constant speed
                    elif self.current_lane == &#34;left&#34;:
                        self.ref_speed_list = copy.copy(self.left_ref_speed) # keep constant speed
                    return
        
            if self.distance_with_ego &gt;= self.lead_follow_far_limit: # the vehicle is following the ego vehicle and far away
                # accelerate
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_max_ref_speed) # accelerate to the max speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_max_ref_speed) # accelerate to the max speed
                self.within_desired_range = False
            
            elif self.distance_with_ego &lt; self.lead_follow_close_limit and self.distance_with_ego &gt; 0: # the vehicle is following 
                                                                                                       # and close to ego
                # deccelerate
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_min_ref_speed) # decelerate to the min speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_min_ref_speed) # decelerate to the min speed
                self.within_desired_range = False
            
            else:
                # vehicle within expected range or follow vehicle before the ego vehicle, which could happen due to change lane
                # keep normal navigation speed
                if self.current_lane == &#34;subject&#34;:
                    self.ref_speed_list = copy.copy(self.subject_ref_speed) # keep constant speed
                elif self.current_lane == &#34;left&#34;:
                    self.ref_speed_list = copy.copy(self.left_ref_speed) # keep constant speed
    
                if self.within_desired_range == False: # just come into the desired range, set the speed
                    local_transform = self.env.get_transform_3d(self.model_uniquename)
                    forward_vector = local_transform.get_forward_vector()
                    vehicle_velocity = carla.Vector3D(x = forward_vector.x * self.subject_ref_speed[0], y = forward_vector.y * self.subject_ref_speed[0], z = forward_vector.z * self.subject_ref_speed[0])
                    self.env.set_vehicle_velocity(self.model_uniquename , vehicle_velocity) # set the velocity
                
                self.within_desired_range = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backend.section_vehicle_control.FullPathVehicleControl" href="#backend.section_vehicle_control.FullPathVehicleControl">FullPathVehicleControl</a></li>
<li><a title="backend.section_vehicle_control.VehicleControlFreeway" href="#backend.section_vehicle_control.VehicleControlFreeway">VehicleControlFreeway</a></li>
<li><a title="backend.multiple_vehicle_control.VehicleControl" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl">VehicleControl</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="backend.section_vehicle_control.LeadFollowVehicleControl.update_distance_with_ego"><code class="name flex">
<span>def <span class="ident">update_distance_with_ego</span></span>(<span>self, ego_transform)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_distance_with_ego(self, ego_transform):
    ego_location = ego_transform.location
    
    # get local location
    local_transform = self.env.get_transform_3d(self.model_uniquename)
    local_location = local_transform.location
    forward_vector = local_transform.get_forward_vector()
    forward_vector_2d = np.array([forward_vector.x,forward_vector.y])
    unit_forward_vector_2d =  forward_vector_2d / np.linalg.norm(forward_vector_2d)
    
    vec_loc_target = np.array([ego_location.x - local_location.x,ego_location.y - local_location.y])
    distance = np.dot(vec_loc_target,unit_forward_vector_2d)
    
    self.distance_with_ego = distance</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backend.section_vehicle_control.FullPathVehicleControl" href="#backend.section_vehicle_control.FullPathVehicleControl">FullPathVehicleControl</a></b></code>:
<ul class="hlist">
<li><code><a title="backend.section_vehicle_control.FullPathVehicleControl.fake_pure_pursuit_control_wrapper" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.fake_pure_pursuit_control_wrapper">fake_pure_pursuit_control_wrapper</a></code></li>
<li><code><a title="backend.section_vehicle_control.FullPathVehicleControl.get_target_index" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.get_target_index">get_target_index</a></code></li>
<li><code><a title="backend.section_vehicle_control.FullPathVehicleControl.pure_pursuit_control" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.pure_pursuit_control">pure_pursuit_control</a></code></li>
<li><code><a title="backend.section_vehicle_control.FullPathVehicleControl.pure_pursuit_control_wrapper" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.pure_pursuit_control_wrapper">pure_pursuit_control_wrapper</a></code></li>
<li><code><a title="backend.section_vehicle_control.FullPathVehicleControl.speed_control" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.speed_control">speed_control</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backend.section_vehicle_control.VehicleControlFreeway"><code class="flex name class">
<span>class <span class="ident">VehicleControlFreeway</span></span>
<span>(</span><span>env, vehicle_config, delta_seconds, allow_collision=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>env</code></strong> :&ensp;<code>CARLA_ENV</code></dt>
<dd>the self-written environment for simulation</dd>
<dt><strong><code>vehicle_config</code></strong> :&ensp;<code>ConfigObj</code></dt>
<dd>the configuration file for this vehicle. The file is created inside the Intersection's add_vehicle function.
containing the trajectory and speed reference for the vehicle. The configuration file should also indicate whether
this vehicle should go or not.</dd>
<dt><strong><code>delta_seconds</code></strong> :&ensp;<code>float</code></dt>
<dd>time between two adjacent simulation step. Used for creating discrete controller</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VehicleControlFreeway(VehicleControl):
    def __init__(self, env, vehicle_config, delta_seconds, allow_collision = True):
        super().__init__(env, vehicle_config, delta_seconds, allow_collision = True)
        
    def _obey_safety_distance(self, current_ref_speed):
        # override the _obey_safety_distance method
        has_vehicle_in_front, distance = self.env.check_vehicle_in_front_freeway(self.model_uniquename, self.safety_distance) #self.env.check_vehicle_in_front_freeway(self.model_uniquename, self.safety_distance)
        
        if has_vehicle_in_front and abs(distance) &lt; self.L / 2 + 1.0 and not self.allow_collision:
            # if vehicle is about to collide with other vehicle and collision is not allowed
            # set the vehicle velocity to 0
            abrupt_stop_vel = carla.Vector3D(x = 0,y = 0,z = 0)
            self.env.set_vehicle_velocity(self.model_uniquename, abrupt_stop_vel) # set the velocity of vehicle
        
        
        if has_vehicle_in_front: 
            #print(&#34;---&#34;)
            #print(&#34;safety_distance: &#34;, self.safety_distance)
            #print(&#34;distance with previous vehicle &#34;, distance)
            return 0.0
        
        return current_ref_speed</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backend.multiple_vehicle_control.VehicleControl" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl">VehicleControl</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backend.section_vehicle_control.FullPathVehicleControl" href="#backend.section_vehicle_control.FullPathVehicleControl">FullPathVehicleControl</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backend.multiple_vehicle_control.VehicleControl" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl">VehicleControl</a></b></code>:
<ul class="hlist">
<li><code><a title="backend.multiple_vehicle_control.VehicleControl.fake_pure_pursuit_control_wrapper" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.fake_pure_pursuit_control_wrapper">fake_pure_pursuit_control_wrapper</a></code></li>
<li><code><a title="backend.multiple_vehicle_control.VehicleControl.get_target_index" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.get_target_index">get_target_index</a></code></li>
<li><code><a title="backend.multiple_vehicle_control.VehicleControl.pure_pursuit_control" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.pure_pursuit_control">pure_pursuit_control</a></code></li>
<li><code><a title="backend.multiple_vehicle_control.VehicleControl.pure_pursuit_control_wrapper" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.pure_pursuit_control_wrapper">pure_pursuit_control_wrapper</a></code></li>
<li><code><a title="backend.multiple_vehicle_control.VehicleControl.speed_control" href="multiple_vehicle_control.html#backend.multiple_vehicle_control.VehicleControl.speed_control">speed_control</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backend" href="index.html">backend</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backend.section_vehicle_control.FullPathVehicleControl" href="#backend.section_vehicle_control.FullPathVehicleControl">FullPathVehicleControl</a></code></h4>
<ul class="">
<li><code><a title="backend.section_vehicle_control.FullPathVehicleControl.update_local_time" href="#backend.section_vehicle_control.FullPathVehicleControl.update_local_time">update_local_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backend.section_vehicle_control.LeadFollowVehicleControl" href="#backend.section_vehicle_control.LeadFollowVehicleControl">LeadFollowVehicleControl</a></code></h4>
<ul class="">
<li><code><a title="backend.section_vehicle_control.LeadFollowVehicleControl.update_distance_with_ego" href="#backend.section_vehicle_control.LeadFollowVehicleControl.update_distance_with_ego">update_distance_with_ego</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backend.section_vehicle_control.VehicleControlFreeway" href="#backend.section_vehicle_control.VehicleControlFreeway">VehicleControlFreeway</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>